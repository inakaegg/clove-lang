[
  {
    "name": "*",
    "signature": "* & nums",
    "doc": "Multiply the numeric arguments left-to-right; zero arguments yield 1.",
    "origin": "core",
    "examples": [
      "(* 2 3 4) ; => 24",
      "(* ) ; => 1"
    ]
  },
  {
    "name": "+",
    "signature": "+ & nums",
    "doc": "Add the numeric arguments left-to-right; zero arguments yield 0.",
    "origin": "core",
    "examples": [
      "(+ 1 2 3) ; => 6",
      "(+ ) ; => 0"
    ]
  },
  {
    "name": "-",
    "signature": "- x & ys",
    "doc": "Negate a single number or subtract each subsequent number from the first.",
    "origin": "core",
    "examples": [
      "(- 10 3 2) ; => 5",
      "(- 5) ; => -5"
    ]
  },
  {
    "name": "->",
    "signature": "-> expr & forms",
    "doc": "Thread expr through forms as first argument of each.",
    "origin": "special form",
    "examples": [
      "(-> {:a {:b 1}} :a :b) ; => 1"
    ]
  },
  {
    "name": "->>",
    "signature": "->> expr & forms",
    "doc": "Thread expr through forms as last argument of each.",
    "origin": "special form",
    "examples": [
      "(->> [1 2 3] (map inc) (take 2) (vec)) ; => [2 3]"
    ]
  },
  {
    "name": "/",
    "signature": "/ x & divisors",
    "doc": "Divide the first number by each subsequent argument; with one argument return its reciprocal (division by zero raises).",
    "origin": "core",
    "examples": [
      "(/ 8 2 2) ; => 2",
      "(/ 2) ; => 0.5"
    ]
  },
  {
    "name": "<",
    "signature": "< & values",
    "doc": "Return true when the arguments form a strictly increasing sequence (zero or one argument returns true).",
    "origin": "core",
    "examples": [
      "(< 1 2 3) ; => true",
      "(< 1 1) ; => false"
    ]
  },
  {
    "name": "<=",
    "signature": "<= & values",
    "doc": "Return true when the arguments never decrease (allows equality; zero or one argument returns true).",
    "origin": "core",
    "examples": [
      "(<= 1 1 2) ; => true",
      "(<= 2 1) ; => false"
    ]
  },
  {
    "name": "=",
    "signature": "= & values",
    "doc": "Return true when all arguments are equal; zero or one argument returns true.",
    "origin": "core",
    "examples": [
      "(= 1 1 1) ; => true",
      "(= 1 2) ; => false"
    ]
  },
  {
    "name": ">",
    "signature": "> & values",
    "doc": "Return true when the arguments are strictly decreasing (zero or one argument returns true).",
    "origin": "core",
    "examples": [
      "(> 3 2 1) ; => true",
      "(> 1 2) ; => false"
    ]
  },
  {
    "name": ">=",
    "signature": ">= & values",
    "doc": "Return true when the arguments never increase (allows equality; zero or one argument returns true).",
    "origin": "core",
    "examples": [
      "(>= 3 3 1) ; => true",
      "(>= 1 2) ; => false"
    ]
  },
  {
    "name": "__DATA__",
    "signature": "__DATA__",
    "doc": "Return the current file's data section as a UTF-8 string; nil when no data section exists.",
    "origin": "special symbol",
    "examples": [
      "(def m (json::parse __DATA__))\n\n__DATA__\n{\"a\":1,\"b\":2}",
      "(def bytes (base64::decode __DATA__))\n\n__DATA__\nSUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4..."
    ]
  },
  {
    "name": "abs",
    "signature": "abs n",
    "doc": "Return the absolute value, preserving int/float shape.",
    "origin": "core",
    "examples": [
      "(abs -3) ; => 3",
      "(abs -1.5) ; => 1.5"
    ]
  },
  {
    "name": "agent",
    "signature": "agent initial",
    "doc": "Create an asynchronous agent holding the initial state; updates are scheduled via agent-send!/agent-send-io!.",
    "origin": "core",
    "examples": [
      "(agent {:count 0}) ; => #<agent state={:count 0} pending=0 processing=false>",
      "(let [a (agent 0)] (agent-deref a)) ; => 0"
    ]
  },
  {
    "name": "agent-await",
    "signature": "agent-await agent",
    "doc": "Block until the agent has processed all queued actions, returning true when it becomes idle.",
    "origin": "core",
    "examples": [
      "(let [a (agent 0)] (agent-send! a inc) (agent-await a) (agent-deref a)) ; => 1",
      "(agent-await (agent 0)) ; => true"
    ]
  },
  {
    "name": "agent-deref",
    "signature": "agent-deref agent",
    "doc": "Return the agent's current state without altering it.",
    "origin": "core",
    "examples": [
      "(agent-deref (agent {:count 0})) ; => {:count 0}",
      "(let [a (agent 1)] (agent-deref a)) ; => 1"
    ]
  },
  {
    "name": "agent-done?",
    "signature": "agent-done? agent",
    "doc": "True when the agent has no pending actions waiting to run.",
    "origin": "core",
    "examples": [
      "(agent-done? (agent 0)) ; => true",
      "(let [a (agent 0)] (agent-send! a (fn [x] (do (time::sleep 50ms) (inc x)))) (agent-done? a)) ; => false"
    ]
  },
  {
    "name": "agent-error",
    "signature": "agent-error agent",
    "doc": "Return the most recent exception thrown while processing agent actions, or nil when none.",
    "origin": "core",
    "examples": [
      "(let [a (agent 0)] (agent-error a)) ; => nil",
      "(let [a (agent 0)] (agent-send! a (fn [_] (/ 1 0))) (agent-await a) (agent-error a)) ; => \"division by zero\""
    ]
  },
  {
    "name": "agent-restart!",
    "signature": "agent-restart! agent value",
    "doc": "Forcefully reset the agent's state to value and clear any recorded error, returning the agent handle.",
    "origin": "core",
    "examples": [
      "(let [a (agent 0)] (agent-restart! a 42) (agent-deref a)) ; => 42",
      "(let [a (agent {:cnt 1})] (agent-restart! a {:cnt 0})) ; => #<agent state={:cnt 0} pending=0 processing=false>"
    ]
  },
  {
    "name": "agent-send!",
    "signature": "agent-send! agent f & args",
    "doc": "Queue an asynchronous action that will call f with the agent's current state followed by args; returns the agent handle.",
    "origin": "core",
    "examples": [
      "(let [a (agent 0)] (agent-send! a (fn [state inc-by] (+ state inc-by)) 5) (agent-await a) (agent-deref a)) ; => 5",
      "(let [a (agent 1)] (agent-send! a (fn [state] (* state 2)))) ; => #<agent state=2 pending=0 processing=false>"
    ]
  },
  {
    "name": "agent-send-io!",
    "signature": "agent-send-io! agent f & args",
    "doc": "Like agent-send! but run on the dedicated I/O thread pool, useful for blocking operations.",
    "origin": "core",
    "examples": [
      "(let [a (agent [])] (agent-send-io! a (fn [state value] (conj state value)) :done) (agent-await a) (agent-deref a)) ; => [:done]",
      "(let [a (agent 0)] (agent-send-io! a inc)) ; => #<agent state=1 pending=0 processing=false>"
    ]
  },
  {
    "name": "agent?",
    "signature": "agent? value",
    "doc": "Predicate that returns true for agent handles.",
    "origin": "core",
    "examples": [
      "(agent? (agent 0)) ; => true",
      "(agent? 42) ; => false"
    ]
  },
  {
    "name": "all-types",
    "signature": "all-types",
    "doc": "Return the set of every registered type symbol known to the runtime.",
    "origin": "core",
    "examples": [
      "(contains? (all-types) :core::Int) ; => true",
      "(> (count (all-types)) 10) ; => true"
    ]
  },
  {
    "name": "and",
    "signature": "and expr*",
    "doc": "Short-circuiting logical conjunction.",
    "origin": "special form",
    "examples": [
      "(and true 1) ; => 1",
      "(and false 1) ; => false"
    ]
  },
  {
    "name": "apply",
    "signature": "apply f & args",
    "doc": "Call f with args, treating the final argument as a collection to be spliced into the call list.",
    "origin": "core",
    "examples": [
      "(apply + [1 2 3 4]) ; => 10",
      "(apply vector 0 (list 1 2) [3 4]) ; => [0 (1 2) 3 4]"
    ]
  },
  {
    "name": "as->",
    "signature": "as-> expr name & forms",
    "doc": "Thread expr binding it to name at each step.",
    "origin": "special form",
    "examples": [
      "(as-> 1 x (+ x 2) (* x 3)) ; => 9"
    ]
  },
  {
    "name": "assoc",
    "signature": "assoc map key value & kvs",
    "doc": "Add or replace key/value pairs in a map, returning a new map.",
    "origin": "core",
    "examples": [
      "(assoc {:a 1} :b 2) ; => {:a 1 :b 2}",
      "(assoc [0 1 2] 1 99) ; => [0 99 2]"
    ]
  },
  {
    "name": "assoc-in",
    "signature": "assoc-in map path value",
    "doc": "Like assoc, but walks a path creating nested maps as needed.",
    "origin": "core",
    "examples": [
      "(assoc-in {:a {:b 1}} [:a :b] 2) ; => {:a {:b 2}}"
    ]
  },
  {
    "name": "assoc-in!",
    "signature": "assoc-in! m path value",
    "doc": "Destructively associate a nested value in a mutable map/vector, creating nested maps as needed.",
    "origin": "core",
    "examples": [
      "(let [m (mut {:a {:b 1}})]\n  (assoc-in! m [:a :b] 2)\n  (get-in m [:a :b])) ; => 2",
      "(let [m (mut {})]\n  (assoc-in! m [:a :b] 1)\n  (get-in m [:a :b])) ; => 1"
    ]
  },
  {
    "name": "async-scope",
    "signature": "async-scope [children] body",
    "doc": "Run body within a structured async scope that links spawned work to the scope lifetime; returns a handle with :cancel!/ :await/ :cancelled? and observability keys.\nchildren must be promise-like\nmain-body must not return promise-like; put it in children or deref it",
    "origin": "special form",
    "examples": [
      "(let [{:keys [await]} (async-scope [(future (fn [] 1))] :done)] (await)) ; => :done",
      "(let [{:keys [cancel! await]} (async-scope [] (chan-take! (async::cancel-chan)))] (cancel!) (await)) ; => nil"
    ]
  },
  {
    "name": "async::scope",
    "signature": "async::scope [children] body",
    "doc": "Alias of async-scope; structured concurrency block that links spawned work to the scope lifetime and returns a handle map (:cancel!/:await/:cancelled?/etc.).",
    "origin": "special form",
    "examples": [
      "(let [{:keys [await]} (async::scope [] :ok)] (await)) ; => :ok"
    ]
  },
  {
    "name": "async::scope-loop",
    "signature": "async::scope-loop bindings & body",
    "doc": "Loop sugar for async-scope: checks (async::cancelled?) each iteration and returns nil when cancelled (body is skipped).",
    "origin": "special form",
    "examples": [
      "(let [{:keys [await]} (async-scope [] (async::scope-loop [n 0] (if (< n 1) (recur (inc n)) :done)))] (await)) ; => nil"
    ]
  },
  {
    "name": "scope-loop",
    "signature": "scope-loop bindings & body",
    "doc": "Alias of async::scope-loop; returns nil when the current async-scope is cancelled (body is skipped).",
    "origin": "special form",
    "examples": [
      "(async::scope-loop [n 0] (when (< n 1) (recur (inc n)))) ; => nil"
    ]
  },
  {
    "name": "add-watch",
    "signature": "add-watch ref key f",
    "doc": "Attach a watcher that will be called with (key ref old-value new-value) whenever the watchable reference changes. Works with atoms, agents, promises, tasks, and futures. Returns the same reference. Alias: atom-add-watch.",
    "origin": "core",
    "examples": [
      "(let [events (atom []) p (promise)] (add-watch p :done (fn [_ _ _ new] (swap! events conj new))) (promise-deliver! p 1) (atom-deref events)) ; => [{:status :fulfilled :value 1}]",
      "(let [hits (atom []) ag (agent {:n 0})] (add-watch ag :track (fn [_ _ old new] (swap! hits conj [old new]))) (agent-send! ag (fn [s] (assoc s :n 1))) (agent-await ag) (atom-deref hits)) ; => [[{:n 0} {:n 1}]]"
    ]
  },
  {
    "name": "atom",
    "signature": "atom value",
    "doc": "Create a mutable reference (atom) holding value.",
    "origin": "core",
    "examples": [
      "(atom 0) ; => #atom<0>",
      "(let [a (atom {:count 0})] (atom-update! a update :count inc) (atom-deref a)) ; => {:count 1}"
    ]
  },
  {
    "name": "atom-add-watch",
    "signature": "atom-add-watch atom key f",
    "doc": "Alias of add-watch for backward compatibility; watches atoms and other watchable references.",
    "origin": "core",
    "examples": [
      "(let [events (atom []) a (atom 0)] (atom-add-watch a :log (fn [_ _ _ new] (swap! events conj new))) (atom-set! a 1) (atom-deref events)) ; => [1]",
      "(atom-add-watch (atom 0) :noop (fn [& _] nil)) ; => #atom<0>"
    ]
  },
  {
    "name": "atom-deref",
    "signature": "atom-deref atom",
    "doc": "Return the current value of atom. Alias: deref.",
    "origin": "core",
    "examples": [
      "(atom-deref (atom 5)) ; => 5",
      "(let [a (atom 1)] (atom-update! a inc) (atom-deref a)) ; => 2"
    ]
  },
  {
    "name": "remove-watch",
    "signature": "remove-watch ref key",
    "doc": "Remove the watcher identified by key from a watchable reference (atom/agent/promise/task/future). Returns true when a watcher was removed. Alias: atom-remove-watch.",
    "origin": "core",
    "examples": [
      "(let [p (promise)] (add-watch p :noop (fn [& _] nil)) (remove-watch p :noop)) ; => true",
      "(let [ag (agent 0)] (remove-watch ag :missing)) ; => false"
    ]
  },
  {
    "name": "atom-remove-watch",
    "signature": "atom-remove-watch atom key",
    "doc": "Alias of remove-watch; removes a watcher from atoms and other watchable references.",
    "origin": "core",
    "examples": [
      "(let [a (atom 0)] (atom-add-watch a :log (fn [& _] nil)) (atom-remove-watch a :log)) ; => true",
      "(atom-remove-watch (atom 0) :missing) ; => false"
    ]
  },
  {
    "name": "atom-set!",
    "signature": "atom-set! atom value",
    "doc": "Set atom to value and return it. Alias: reset!.",
    "origin": "core",
    "examples": [
      "(atom-set! (atom 0) 42) ; => 42",
      "(let [a (atom true)] (atom-set! a false) (atom-deref a)) ; => false"
    ]
  },
  {
    "name": "atom-set-validator!",
    "signature": "atom-set-validator! atom validator-or-nil",
    "doc": "Set or clear the validator function that must accept every new value written to the atom; returns the atom handle.",
    "origin": "core",
    "examples": [
      "(let [a (atom 0)] (atom-set-validator! a (fn [x] (>= x 0))) (try (atom-set! a -1) (catch RuntimeError _ :invalid))) ; => :invalid",
      "(let [a (atom 0)] (atom-set-validator! a nil) (atom-set! a -5)) ; => -5"
    ]
  },
  {
    "name": "atom-update!",
    "signature": "atom-update! atom f & args",
    "doc": "Atomically apply f to the current value with args and store the result. Alias: swap!.",
    "origin": "core",
    "examples": [
      "(let [c (atom 0)] (atom-update! c inc)) ; => 1",
      "(let [c (atom 1)] (atom-update! c + 5) (atom-deref c)) ; => 6"
    ]
  },
  {
    "name": "atom-validator",
    "signature": "atom-validator atom",
    "doc": "Return the current validator function for the atom or nil when none is installed.",
    "origin": "core",
    "examples": [
      "(atom-validator (atom 0)) ; => nil",
      "(let [a (atom 0)] (atom-set-validator! a (fn [x] (>= x 0))) (some? (atom-validator a))) ; => true"
    ]
  },
  {
    "name": "atom?",
    "signature": "atom? value",
    "doc": "Return true when value is an atom.",
    "origin": "core",
    "examples": [
      "(atom? (atom 0)) ; => true",
      "(atom? 10) ; => false"
    ]
  },
  {
    "name": "bench",
    "signature": "bench iterations callable",
    "doc": "Call the zero-arity callable iterations times and return the measurement map {:result v :elapsed-ms n :avg-ms n :runs iterations} (milliseconds as float).",
    "origin": "core",
    "examples": [
      "(get (bench 5 (fn [] (+ 1 2))) :runs) ; => 5",
      "(get (bench 10 (fn [] (reduce + (range 5)))) :result) ; => 10"
    ]
  },
  {
    "name": "bit-and",
    "signature": "bit-and & ints",
    "doc": "Bitwise AND across all integer arguments; no arguments yield -1 (all bits set).",
    "origin": "core",
    "examples": [
      "(bit-and 15 7 3) ; => 3",
      "(bit-and) ; => -1"
    ]
  },
  {
    "name": "bit-and-not",
    "signature": "bit-and-not value & masks",
    "doc": "Bitwise AND the first int with the bitwise negation of each following mask.",
    "origin": "core",
    "examples": [
      "(bit-and-not 15 3) ; => 12",
      "(bit-and-not 15 3 1) ; => 12"
    ]
  },
  {
    "name": "bit-clear",
    "signature": "bit-clear value bit",
    "doc": "Return value with the indexed bit cleared (set to 0).",
    "origin": "core",
    "examples": [
      "(bit-clear 15 1) ; => 13",
      "(bit-clear 8 3) ; => 0"
    ]
  },
  {
    "name": "bit-flip",
    "signature": "bit-flip value bit",
    "doc": "Toggle (XOR) the indexed bit of the integer.",
    "origin": "core",
    "examples": [
      "(bit-flip 8 0) ; => 9",
      "(bit-flip 5 0) ; => 4"
    ]
  },
  {
    "name": "bit-not",
    "signature": "bit-not value",
    "doc": "Bitwise complement of the integer.",
    "origin": "core",
    "examples": [
      "(bit-not 0) ; => -1",
      "(bit-not -1) ; => 0"
    ]
  },
  {
    "name": "bit-or",
    "signature": "bit-or & ints",
    "doc": "Bitwise OR across all integer arguments; zero arguments yield 0.",
    "origin": "core",
    "examples": [
      "(bit-or 1 2 4) ; => 7",
      "(bit-or) ; => 0"
    ]
  },
  {
    "name": "bit-set",
    "signature": "bit-set value bit",
    "doc": "Return value with the indexed bit set to 1.",
    "origin": "core",
    "examples": [
      "(bit-set 0 3) ; => 8",
      "(bit-set 5 1) ; => 7"
    ]
  },
  {
    "name": "bit-shift-left",
    "signature": "bit-shift-left value bits",
    "doc": "Shift the integer value left by bits (wrapping within 64 bits).",
    "origin": "core",
    "examples": [
      "(bit-shift-left 1 3) ; => 8",
      "(bit-shift-left -2 1) ; => -4"
    ]
  },
  {
    "name": "bit-shift-right",
    "signature": "bit-shift-right value bits",
    "doc": "Arithmetic right shift of the integer value by bits (preserves sign).",
    "origin": "core",
    "examples": [
      "(bit-shift-right 16 2) ; => 4",
      "(bit-shift-right -8 1) ; => -4"
    ]
  },
  {
    "name": "bit-test",
    "signature": "bit-test value bit",
    "doc": "Return true when the indexed bit of value is 1.",
    "origin": "core",
    "examples": [
      "(bit-test 5 0) ; => true",
      "(bit-test 4 0) ; => false"
    ]
  },
  {
    "name": "bit-xor",
    "signature": "bit-xor & ints",
    "doc": "Bitwise XOR across all integer arguments; zero arguments yield 0.",
    "origin": "core",
    "examples": [
      "(bit-xor 1 3) ; => 2",
      "(bit-xor 5 5 5) ; => 5"
    ]
  },
  {
    "name": "blank?",
    "signature": "blank? s",
    "doc": "True when the string contains only Unicode whitespace characters.",
    "origin": "string",
    "examples": [
      "(blank? \"  \n\t\") ; => true",
      "(blank? \"now\") ; => false"
    ]
  },
  {
    "name": "boolean",
    "signature": "boolean x",
    "doc": "Return true when x is truthy (non-nil and not false).",
    "origin": "core",
    "examples": [
      "(boolean nil) ; => false",
      "(boolean 0) ; => true"
    ]
  },
  {
    "name": "boolean?",
    "signature": "boolean? x",
    "doc": "True when x is either true or false (and false for all other values).",
    "origin": "core",
    "examples": [
      "(boolean? true) ; => true",
      "(boolean? 0) ; => false"
    ]
  },
  {
    "name": "break",
    "signature": "break",
    "doc": "Exit from the nearest loop/doseq.",
    "origin": "special form",
    "examples": [
      "(comment (break)) ; => nil ; Exit from the nearest loop"
    ]
  },
  {
    "name": "butlast",
    "signature": "butlast coll",
    "doc": "Return the collection without its final element; lists/vectors retain their type and lazy seqs realize into vectors.",
    "origin": "core",
    "examples": [
      "(butlast [1 2 3]) ; => [1 2]",
      "(butlast (range 3)) ; => [0 1]"
    ]
  },
  {
    "name": "cancel-chan",
    "signature": "cancel-chan",
    "doc": "Return the current async-scope cancel channel; it closes when the scope is cancelled and stays open forever outside a scope.",
    "origin": "core",
    "examples": [
      "(let [{:keys [cancel! cancel-chan await]} (async-scope [] :ok)] (cancel!) [(await) (chan-closed? cancel-chan)]) ; => [:ok true]"
    ]
  },
  {
    "name": "cancelled?",
    "signature": "cancelled?",
    "doc": "Return true when the nearest async-scope has been cancelled; returns false when running outside any scope.",
    "origin": "core",
    "examples": [
      "(let [{:keys [cancel! await]} (async-scope [] (do (chan-take! (async::cancel-chan)) (async::cancelled?)))] (cancel!) (await)) ; => true"
    ]
  },
  {
    "name": "async::scope-cancelled?",
    "signature": "async::scope-cancelled?",
    "doc": "Alias of async::cancelled?; returns true when the nearest async-scope has been cancelled.",
    "origin": "core",
    "examples": [
      "(let [{:keys [cancel! await]} (async-scope [] (do (chan-take! (async::cancel-chan)) (async::scope-cancelled?)))] (cancel!) (await)) ; => true"
    ]
  },
  {
    "name": "async::scope-cancel-chan",
    "signature": "async::scope-cancel-chan",
    "doc": "Alias of async::cancel-chan; returns the current async-scope cancel channel.",
    "origin": "core",
    "examples": [
      "(let [{:keys [cancel! await]} (async-scope [] (do (chan-take! (async::scope-cancel-chan)) :done))] (cancel!) (await)) ; => :done"
    ]
  },
  {
    "name": "async::scope-select",
    "signature": "async::scope-select cases [opts]",
    "doc": "Cancel-aware select. Automatically adds the current async-scope cancel channel, returning :cancelled when cancellation wins. Otherwise behaves like select and returns a vector: [value chan] for takes, [true chan] for puts, or [default nil] when no cases are immediately ready (with :default making the call non-blocking). opts may contain {:timeout duration :default value}.",
    "origin": "core",
    "examples": [
      "(let [{:keys [cancel! await]} (async-scope [] (async::scope-select [(timeout 50ms)]))] (cancel!) (await)) ; => :cancelled",
      "(let [c (chan 1)] (chan-put! c :ok) (async::scope-select [c])) ; => [:ok #<chan id=1 cap=1 len=0 closed=false>]",
      "(let [c (chan 1)] (async::scope-select [[:put c :ok]])) ; => [true #<chan id=1 cap=1 len=1 closed=false>]"
    ]
  },
  {
    "name": "scope-select",
    "signature": "scope-select cases [opts]",
    "doc": "Alias of async::scope-select; cancel-aware select that returns :cancelled when the current async-scope is cancelled. Otherwise returns the same vector shape as select: [value chan] or [true chan] (or [default nil] when no cases are immediately ready).",
    "origin": "core",
    "examples": [
      "(let [{:keys [cancel! await]} (async-scope [] (scope-select [(timeout 20ms)]))] (cancel!) (await)) ; => :cancelled",
      "(let [c (chan 1)] (chan-put! c 1) (scope-select [c])) ; => [1 #<chan id=1 cap=1 len=0 closed=false>]"
    ]
  },
  {
    "name": "capitalize",
    "signature": "capitalize s",
    "doc": "Upper-case the first character of s and lower-case the remainder.",
    "origin": "string",
    "examples": [
      "(capitalize \"clove\") ; => \"Clove\"",
      "(capitalize \"\u00dfeta\") ; => \"SSeta\""
    ]
  },
  {
    "name": "chan",
    "signature": "chan [capacity]",
    "doc": "Create a channel; with no capacity it is unbounded, 0 creates an unbuffered channel, otherwise it buffers up to capacity values.",
    "origin": "core",
    "examples": [
      "(chan) ; => #<chan id=1 cap=unbounded len=0 closed=false>",
      "(let [c (chan 1)] (chan-put! c :ok) (chan-take! c)) ; => :ok"
    ]
  },
  {
    "name": "chan-close!",
    "signature": "chan-close! chan",
    "doc": "Close the channel so future puts fail; returns true.",
    "origin": "core",
    "examples": [
      "(chan-close! (chan)) ; => true",
      "(let [c (chan 1)] (chan-put! c :value) (chan-close! c) (chan-closed? c)) ; => true"
    ]
  },
  {
    "name": "current-file",
    "signature": "current-file",
    "doc": "Return the current source file path, or nil when running in REPL/virtual sources.",
    "origin": "core",
    "examples": [
      "(comment (current-file)) ; => nil ; returns nil in REPL/virtual sources"
    ]
  },
  {
    "name": "current-ns",
    "signature": "current-ns",
    "doc": "Return the current namespace symbol.",
    "origin": "special form",
    "examples": [
      "(current-ns) ; => user"
    ]
  },
  {
    "name": "chan-closed?",
    "signature": "chan-closed? chan",
    "doc": "Return true once the channel has been closed.",
    "origin": "core",
    "examples": [
      "(chan-closed? (chan)) ; => false",
      "(let [c (chan)] (chan-close! c) (chan-closed? c)) ; => true"
    ]
  },
  {
    "name": "chan-put!",
    "signature": "chan-put! chan value",
    "doc": "Put value onto the channel, blocking when necessary; returns true when delivered (false once closed).",
    "origin": "core",
    "examples": [
      "(let [c (chan 1)] (chan-put! c :ok)) ; => true",
      "(let [c (chan)] (chan-close! c) (chan-put! c 1)) ; => false"
    ]
  },
  {
    "name": "chan-take!",
    "signature": "chan-take! chan",
    "doc": "Take and return the next value from the channel, blocking until one is available; returns nil when the channel closes with no value.",
    "origin": "core",
    "examples": [
      "(let [c (chan 1)] (chan-put! c 42) (chan-take! c)) ; => 42",
      "(chan-take! (timeout 0)) ; => nil"
    ]
  },
  {
    "name": "chan?",
    "signature": "chan? value",
    "doc": "True when value is a channel handle (nil counts as false).",
    "origin": "core",
    "examples": [
      "(chan? (chan)) ; => true",
      "(chan? nil) ; => false"
    ]
  },
  {
    "name": "cli::argv",
    "signature": "cli::argv",
    "doc": "Return the current process arguments as a vector of strings (including the executable name).",
    "origin": "cli",
    "examples": [
      "(every? string? (cli::argv)) ; => true",
      "(>= (count (cli::argv)) 1) ; => true"
    ]
  },
  {
    "name": "cli::env",
    "signature": "cli::env",
    "doc": "Return a map of all environment variables where keys and values are strings.",
    "origin": "cli",
    "examples": [
      "(map? (cli::env)) ; => true",
      "(contains? (cli::env) \"PATH\") ; => true"
    ]
  },
  {
    "name": "cli::env-get",
    "signature": "cli::env-get key [default]",
    "doc": "Fetch an environment variable by name, returning default (or nil) when missing.",
    "origin": "cli",
    "examples": [
      "(some? (cli::env-get \"HOME\")) ; => true",
      "(cli::env-get \"_NOT_SET_\" :none) ; => :none"
    ]
  },
  {
    "name": "cli::exit",
    "signature": "cli::exit [code]",
    "doc": "Exit the current process immediately with the optional integer code (defaults to 0).",
    "origin": "cli",
    "examples": [
      "(comment (cli::exit 0)) ; => nil ; Exit the process with code 0"
    ]
  },
  {
    "name": "cli::parse-opts",
    "signature": "cli::parse-opts argv spec",
    "doc": "Parse argv (vector of strings) against spec (vector of option maps). Spec keys: :id (required), :short, :long, :arg?, :default, :required?. Returns {:options {:id value} :args [...] :errors [...]}.",
    "origin": "cli",
    "examples": [
      "(let [argv [\"-p\" \"8080\" \"--flag\" \"rest\"] spec [{:id :port :short \"-p\" :arg? true :default \"3000\" :required? true} {:id :flag :long \"--flag\"}]] (cli::parse-opts argv spec)) ; => {:args [\"rest\"] :errors [] :options {:flag true :port \"8080\"}}",
      "(get (cli::parse-opts [] [{:id :port :long \"--port\" :arg? true :required? true}]) :errors) ; => [\"required option missing: port\"]",
      "(get (cli::parse-opts [\"--unknown\"] [{:id :flag :long \"--flag\"}]) :errors) ; => [\"unknown option --unknown\"]"
    ]
  },
  {
    "name": "cli::parse-opts-adv",
    "signature": "cli::parse-opts-adv argv spec",
    "doc": "Advanced option parser. Spec keys: :id (required), :short, :long, :arg?, :default, :required?, plus :alias (extra flags), :coerce (:int/:float/:bool/:string), :collect? (or :collect). Supports -abc short bundles (flags only), --key=value, and stops parsing after --.",
    "origin": "cli",
    "examples": [
      "(let [argv [\"--port=8080\" \"-I\" \"src\" \"-I\" \"test\" \"--verbose\" \"--\" \"--raw\"] spec [{:id :port :long \"--port\" :arg? true :coerce :int} {:id :include :short \"-I\" :arg? true :collect? true} {:id :verbose :alias [\"-v\" \"--verbose\"]}]] (cli::parse-opts-adv argv spec)) ; => {:args [\"--raw\"] :errors [] :options {:include [\"src\" \"test\"] :port 8080 :verbose true}}",
      "(get (cli::parse-opts-adv [\"-abc\"] [{:id :a :short \"-a\"} {:id :b :short \"-b\"} {:id :c :short \"-c\"}]) :options) ; => {:a true :b true :c true}"
    ]
  },
  {
    "name": "coll?",
    "signature": "coll? value",
    "doc": "Return true when value is a collection (list, vector, map, or set).",
    "origin": "core",
    "examples": [
      "(coll? [1 2 3]) ; => true",
      "(coll? 10) ; => false"
    ]
  },
  {
    "name": "comment",
    "signature": "comment & body",
    "doc": "Ignore body expressions and return nil.",
    "origin": "special form",
    "examples": [
      "(comment (+ 1 2)) ; => nil"
    ]
  },
  {
    "name": "comp",
    "signature": "comp & fns",
    "doc": "Return a function applying fns right-to-left and passing the result forward.",
    "origin": "core",
    "examples": [
      "((comp inc inc) 1) ; => 3",
      "((comp str keyword) :ok) ; => \"ok\""
    ]
  },
  {
    "name": "compare",
    "signature": "compare a b",
    "doc": "Return -1, 0, or 1 depending on the ordering of comparable values.",
    "origin": "core",
    "examples": [
      "(compare 1 2) ; => -1",
      "(compare \"b\" \"a\") ; => 1"
    ]
  },
  {
    "name": "compare-desc",
    "signature": "compare-desc a b",
    "doc": "Compare two values in descending order; returns -1, 0, or 1.",
    "origin": "core",
    "examples": [
      "(compare-desc 1 2) ; => 1",
      "(compare-desc \"b\" \"a\") ; => -1"
    ]
  },
  {
    "name": "compare-and-set!",
    "signature": "compare-and-set! atom expected new-value",
    "doc": "Atomically set atom to new-value when current value equals expected; returns true on success.",
    "origin": "core",
    "examples": [
      "(def a (atom 1)) (compare-and-set! a 1 2) ; => true",
      "(compare-and-set! a 1 3) ; => false"
    ]
  },
  {
    "name": "complement",
    "signature": "complement f",
    "doc": "Return a function that negates the boolean result of f.",
    "origin": "core",
    "examples": [
      "((complement even?) 3) ; => true",
      "((complement nil?) 0) ; => true"
    ]
  },
  {
    "name": "concat",
    "signature": "concat & colls",
    "doc": "Eagerly concatenate colls into a single vector.",
    "origin": "core",
    "examples": [
      "(concat [1 2] (list 3 4)) ; => [1 2 3 4]",
      "(concat [:a] [:b] [:c]) ; => [:a :b :c]"
    ]
  },
  {
    "name": "cond",
    "signature": "cond test expr & more",
    "doc": "Evaluate tests in order and return the expr for the first truthy test.",
    "origin": "special form",
    "examples": [
      "(cond false :a true :b) ; => :b"
    ]
  },
  {
    "name": "cond->",
    "signature": "cond-> expr & clauses",
    "doc": "Conditionally thread expr as first arg when tests are truthy.",
    "origin": "special form",
    "examples": [
      "(cond-> {:a 1} true (assoc :b 2)) ; => {:a 1 :b 2}"
    ]
  },
  {
    "name": "cond->>",
    "signature": "cond->> expr & clauses",
    "doc": "Conditionally thread expr as last arg when tests are truthy.",
    "origin": "special form",
    "examples": [
      "(cond->> 1 true (vector)) ; => [1]"
    ]
  },
  {
    "name": "condp",
    "signature": "condp pred test-expr & clauses",
    "doc": "Compare test-expr with clauses using pred; returns the first matching result.",
    "origin": "special form",
    "examples": [
      "(condp = 3 1 :one 2 :two 3 :three :default) ; => :three",
      "(condp re-find \"foobarbaz\" /foo/ :foo /bar/ :bar :none) ; => :foo"
    ]
  },
  {
    "name": "conj",
    "signature": "conj coll & values",
    "doc": "Add values to a collection, preserving its type (lists add to front, vectors to back, sets/maps merge elements).",
    "origin": "core",
    "examples": [
      "(conj [1 2] 3) ; => [1 2 3]"
    ]
  },
  {
    "name": "cons",
    "signature": "cons value coll",
    "doc": "Prepend value to coll, yielding a sequence with value first.",
    "origin": "core",
    "examples": [
      "(cons 0 '(1 2)) ; => (0 1 2)"
    ]
  },
  {
    "name": "constantly",
    "signature": "constantly value",
    "doc": "Return a function that always yields value, ignoring its arguments.",
    "origin": "core",
    "examples": [
      "((constantly 42) :ignored) ; => 42",
      "((constantly :ok) 1 2 3) ; => :ok"
    ]
  },
  {
    "name": "contains?",
    "signature": "contains? coll key-or-index",
    "doc": "True when a map/set contains the key; for vector/list it checks index existence. To test membership by value, use includes?.",
    "origin": "core",
    "examples": [
      "(contains? {:a 1 :b 2} :a) ; => true",
      "(contains? [10 20] 1) ; => true"
    ]
  },
  {
    "name": "count",
    "signature": "count coll",
    "doc": "Return the number of items in coll (nil counts as 0); works on strings and other countable types.",
    "origin": "core",
    "examples": [
      "(count [1 2 3]) ; => 3"
    ]
  },
  {
    "name": "cycle",
    "signature": "cycle coll",
    "doc": "Return an infinite lazy sequence cycling through coll; empty coll yields an empty sequence.",
    "origin": "core",
    "examples": [
      "(take 5 (cycle [1 2])) ; => [1 2 1 2 1]",
      "(take 4 (cycle [:a])) ; => [:a :a :a :a]"
    ]
  },
  {
    "name": "create-ns",
    "signature": "create-ns name",
    "doc": "Create or return the namespace with the given name.",
    "origin": "special form",
    "examples": [
      "(comment (create-ns 'app::scratch)) ; => nil ; Create or return a namespace"
    ]
  },
  {
    "name": "dag::defaults",
    "signature": "dag::defaults",
    "doc": "Return default parallel execution options (workers/chunk/buffer/ordered?/on-error).",
    "origin": "core",
    "examples": [
      "(get (dag::defaults) :ordered?) ; => true"
    ]
  },
  {
    "name": "dag::normalize-opts",
    "signature": "dag::normalize-opts opts",
    "doc": "Normalize parallel opts, accepting :max-parallel as an alias for :workers and filling defaults.",
    "origin": "core",
    "examples": [
      "(get (dag::normalize-opts {:max-parallel 2}) :workers) ; => 2",
      "(get (dag::normalize-opts {:max-parallel 2}) :buffer) ; => 8"
    ]
  },
  {
    "name": "dag::pfilter",
    "signature": "dag::pfilter pred coll\ndag::pfilter pred coll opts\ndag::pfilter opts pred coll\ndag::pfilter [x coll] body\ndag::pfilter [x coll] opts body\ndag::pfilter opts [x coll] body",
    "doc": "Parallel filter using fixed workers and chunked execution; opts: :workers/:chunk/:buffer/:ordered?/:on-error (alias: :max-parallel).",
    "origin": "core",
    "examples": [
      "(dag::pfilter odd? [1 2 3 4]) ; => [1 3]",
      "(dag::pfilter {:workers 2} odd? [1 2 3 4]) ; => [1 3]",
      "(dag::pfilter {:workers 2} [x [1 2 3 4]] (odd? x)) ; => [1 3]"
    ]
  },
  {
    "name": "dag::pmap",
    "signature": "dag::pmap f coll\ndag::pmap f coll opts\ndag::pmap opts f coll\ndag::pmap [x coll] body\ndag::pmap [x coll] opts body\ndag::pmap opts [x coll] body",
    "doc": "Parallel map using fixed workers and chunked execution; opts: :workers/:chunk/:buffer/:ordered?/:on-error (alias: :max-parallel).",
    "origin": "core",
    "examples": [
      "(vec (dag::pmap inc [1 2 3])) ; => [2 3 4]",
      "(vec (dag::pmap {:workers 2} inc [1 2 3])) ; => [2 3 4]",
      "(dag::pmap {:workers 2} [x [1 2 3]] (+ x 1)) ; => [2 3 4]"
    ]
  },
  {
    "name": "deftype",
    "signature": "deftype Name doc? attr-map? {field type & more}",
    "doc": "Define a record-like type with typed fields; emits a constructor function with the same name. Optional docstring and attr-map may appear after the name in any order.",
    "origin": "special form",
    "examples": [
      "(deftype Point {:x Int :y Int})",
      "(Point {:x 1 :y 2}) ; => {:type user::Point :x 1 :y 2}"
    ]
  },
  {
    "name": "defenum",
    "signature": "defenum Name doc? attr-map? variants",
    "doc": "Register a sum/enum type in the current namespace; each member must be a product type in the same namespace or a spread of another enum (e.g. *OtherEnum). Missing member types are auto-created as empty products (constructors/predicates are emitted). Optional docstring and attr-map may appear after the name in any order.",
    "origin": "special form",
    "examples": [
      "(defenum Color Red Green) (enum-members :user::Color) ; => [:user::Red :user::Green]",
      "(defenum Pets Dog Cat) (type-of (Dog)) ; => user::Dog",
      "(defenum Animals *Pets Salmon) (enum-members :user::Animals) ; => [:user::Dog :user::Cat :user::Salmon]"
    ]
  },
  {
    "name": "debug",
    "signature": "debug",
    "doc": "Enter a debug REPL session.",
    "origin": "special form",
    "examples": [
      "(comment (debug)) ; => nil ; Enter a debug REPL session"
    ]
  },
  {
    "name": "dec",
    "signature": "dec n",
    "doc": "Decrease the number by 1, preserving int/float shape.",
    "origin": "core",
    "examples": [
      "(dec 5) ; => 4",
      "(dec 2.5) ; => 1.5"
    ]
  },
  {
    "name": "dedupe",
    "signature": "dedupe coll",
    "doc": "Remove only consecutive duplicate items from coll.",
    "origin": "core",
    "examples": [
      "(dedupe [1 1 2 2 1]) ; => [1 2 1]",
      "(dedupe [:a :a :b :b :c]) ; => [:a :b :c]"
    ]
  },
  {
    "name": "delay",
    "signature": "delay & body",
    "doc": "Return a delay of body that is realized on first deref and cached thereafter.",
    "origin": "special form",
    "examples": [
      "(def d (delay (+ 1 2))) (deref d) ; => 3",
      "(realized? (delay 1)) ; => false"
    ]
  },
  {
    "name": "delay?",
    "signature": "delay? value",
    "doc": "Return true when value is a delay.",
    "origin": "core",
    "examples": [
      "(delay? (delay 1)) ; => true",
      "(delay? 1) ; => false"
    ]
  },
  {
    "name": "def",
    "signature": "def name doc? attr-map? value",
    "doc": "Define a symbol in current namespace. Optional docstring and attr-map may appear after the name in any order.",
    "origin": "special form",
    "examples": [
      "(do (def x 1) x) ; => 1"
    ]
  },
  {
    "name": "defn",
    "signature": "defn name doc? attr-map? [params] body",
    "doc": "Define a named function. Optional docstring and attr-map may appear after the name in any order.",
    "origin": "special form",
    "examples": [
      "(do (defn f [x] (* x 2)) (f 3)) ; => 6"
    ]
  },
  {
    "name": "deliver",
    "signature": "deliver promise value",
    "doc": "Resolve a promise with value; returns true when it succeeds (no effect if already delivered).",
    "origin": "core",
    "examples": [
      "(let [p (promise)] (deliver p 42)) ; => true",
      "(deliver (promise) :ready) ; => true"
    ]
  },
  {
    "name": "deref",
    "signature": "deref ref",
    "doc": "Dereference an atom, promise, task, future, or agent and return its value.",
    "origin": "core",
    "examples": [
      "(deref (atom 1)) ; => 1",
      "(deref (future (fn [] 10))) ; => 10"
    ]
  },
  {
    "name": "done?",
    "signature": "done? ref",
    "doc": "Return true when an async reference (promise/task/future) has completed or when an agent has no pending work.",
    "origin": "core",
    "examples": [
      "(done? (promise)) ; => false",
      "(let [f (future (fn [] 1))] (future-deref f) (done? f)) ; => true",
      "(let [ag (agent 0)] (agent-send! ag inc) (done? ag)) ; => false"
    ]
  },
  {
    "name": "describe",
    "signature": "describe type-symbol",
    "doc": "Return metadata about the named type (namespace, kind, doc, fields/members, etc.).",
    "origin": "core",
    "examples": [
      "(get (describe :core::Int) :kind) ; => :primitive",
      "(get (describe :core::Vector) :ns) ; => :core"
    ]
  },
  {
    "name": "describe-type",
    "signature": "describe-type type-symbol",
    "doc": "Alias of describe; kept for compatibility.",
    "origin": "core",
    "examples": [
      "(get (describe-type :core::Map) :kind) ; => :product",
      "(get (describe-type :core::Bool) :members) ; => [:core::Bool::false :core::Bool::true]"
    ]
  },
  {
    "name": "disj",
    "signature": "disj set & values",
    "doc": "Remove values from a set (nil stays nil).",
    "origin": "core",
    "examples": [
      "(disj #{:a :b} :a) ; => #{:b}"
    ]
  },
  {
    "name": "dissoc",
    "signature": "dissoc map & keys",
    "doc": "Remove the given keys from a map, returning a new map.",
    "origin": "core",
    "examples": [
      "(dissoc {:a 1 :b 2} :a) ; => {:b 2}"
    ]
  },
  {
    "name": "distinct",
    "signature": "distinct coll",
    "doc": "Return a vector of the distinct items in coll, preserving the first occurrence of each.",
    "origin": "core",
    "examples": [
      "(distinct [1 2 1 2]) ; => [1 2]",
      "(distinct [:a :a :b nil :b]) ; => [:a :b nil]"
    ]
  },
  {
    "name": "do",
    "signature": "do expr*",
    "doc": "Evaluate expressions sequentially.",
    "origin": "special form",
    "examples": [
      "(do 1 2 3) ; => 3"
    ]
  },
  {
    "name": "doc",
    "signature": "doc target",
    "doc": "Return the docstring for the symbol or value (or nil).",
    "origin": "core",
    "examples": [
      "(doc 'defn) ; => \"Define a named function. Optional docstring and attr-map may appear after the name in any order.\"",
      "(defn f \"hi\" [] 1) (doc 'f) ; => \"hi\""
    ]
  },
  {
    "name": "dorun",
    "signature": "dorun coll\ndorun n coll",
    "doc": "Realize items of coll (optionally first n) for side effects, returning nil.",
    "origin": "core",
    "examples": [
      "(dorun (map println [1 2])) ; => nil ; prints lines",
      "(dorun 1 (map println [1 2])) ; => nil ; realizes one item"
    ]
  },
  {
    "name": "doseq",
    "signature": "doseq [bindings] body",
    "doc": "Iterate for side effects across sequences of bindings; returns nil.",
    "origin": "special form",
    "examples": [
      "(doseq [x [1 2]] (println \"x =\" x)) ; => nil ; prints lines for each x",
      "(doseq [x [1 2] y [:a :b]] (println x y)) ; => nil ; emits 4 pairs for side effects"
    ]
  },
  {
    "name": "dotimes",
    "signature": "dotimes [n binding] body",
    "doc": "Execute body n times with binding from 0 to n-1; returns nil.",
    "origin": "special form",
    "examples": [
      "(dotimes [n 0] n) ; => nil"
    ]
  },
  {
    "name": "doto",
    "signature": "doto target & forms",
    "doc": "Evaluate target once, apply each form with target as the first argument, and return target.",
    "origin": "special form",
    "examples": [
      "(let [a (atom 0)] (doto a (swap! inc) (swap! inc)) (deref a)) ; => 2"
    ]
  },
  {
    "name": "drop",
    "signature": "drop n coll",
    "doc": "Skip the first n items of coll, returning the remainder. When coll is a seq, the remainder stays lazy to avoid realizing unbounded sequences; use vec if you need a concrete collection.",
    "origin": "core",
    "examples": [
      "(vec (drop 2 [1 2 3 4])) ; => [3 4]"
    ]
  },
  {
    "name": "drop-last",
    "signature": "drop-last coll\ndrop-last n coll",
    "doc": "Return a vector without the last n items (defaults to 1); seq inputs are fully realized.",
    "origin": "core",
    "examples": [
      "(drop-last [1 2 3]) ; => [1 2]",
      "(drop-last 2 [1 2 3 4]) ; => [1 2]"
    ]
  },
  {
    "name": "drop-while",
    "signature": "drop-while pred coll",
    "doc": "Skip items while pred returns truthy, then return the remaining sequence. When coll is a seq, the remainder stays lazy to avoid realizing unbounded sequences; use vec if you need a concrete collection. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(vec (drop-while neg? [-2 -1 0 1])) ; => [0 1]",
      "(drop-while odd? [1 3 4 5]) ; => [4 5]",
      "(vec (drop-while [x [-2 -1 0 1]] (neg? x))) ; => [0 1]"
    ]
  },
  {
    "name": "empty",
    "signature": "empty coll",
    "doc": "Return an empty collection of the same logical type (string -> empty string, seq -> empty seq, nil -> nil).",
    "origin": "core",
    "examples": [
      "(empty [1 2 3]) ; => []",
      "(empty {:a 1}) ; => {}"
    ]
  },
  {
    "name": "empty?",
    "signature": "empty? coll",
    "doc": "Return true when the collection has no elements; nil counts as empty.",
    "origin": "core",
    "examples": [
      "(empty? []) ; => true"
    ]
  },
  {
    "name": "ends-with?",
    "signature": "ends-with? [s suffix]",
    "doc": "True when the string ends with suffix.",
    "origin": "string",
    "examples": [
      "(ends-with? \"clove\" \"ve\") ; => true",
      "(ends-with? \"clove\" \"cl\") ; => false"
    ]
  },
  {
    "name": "enum-members",
    "signature": "enum-members type-symbol",
    "doc": "Return the vector of member symbols for the named sum/enum type.",
    "origin": "core",
    "examples": [
      "(enum-members :core::Bool) ; => [:core::Bool::false :core::Bool::true]"
    ]
  },
  {
    "name": "env::get",
    "signature": "env::get key",
    "doc": "Return the environment variable value for key, or nil when missing.",
    "origin": "config",
    "examples": [
      "(comment (env::get \"HOME\")) ; => nil ; returns the value or nil"
    ]
  },
  {
    "name": "env::has?",
    "signature": "env::has? key",
    "doc": "Return true when the environment variable is set.",
    "origin": "config",
    "examples": [
      "(env::has? \"PATH\") ; => true"
    ]
  },
  {
    "name": "env::parse-file",
    "signature": "env::parse-file path",
    "doc": "Read a .env-style file and return a map of key/value strings.",
    "origin": "config",
    "examples": [
      "(env::parse-file \"data::fixtures/doc_examples/config/.env\") ; => {\"MODE\" \"dev\" \"PORT\" \"3000\"}",
      "(contains? (env::parse-file \"data::fixtures/doc_examples/config/.env\") \"PORT\") ; => true"
    ]
  },
  {
    "name": "env::vars",
    "signature": "env::vars",
    "doc": "Return a map of environment variables.",
    "origin": "config",
    "examples": [
      "(comment (env::vars)) ; => nil ; returns map of env vars"
    ]
  },
  {
    "name": "escape",
    "signature": "escape s replacements-map",
    "doc": "Replace characters in s according to the replacements map (string keys to replacement strings).",
    "origin": "string",
    "examples": [
      "(escape \"<tag>\" {\"<\" \"&lt;\" \">\" \"&gt;\"}) ; => \"&lt;tag&gt;\"",
      "(escape \"a&b\" {\"&\" \"&amp;\"}) ; => \"a&amp;b\""
    ]
  },
  {
    "name": "eval",
    "signature": "eval form",
    "doc": "Evaluate the given form as code in the current environment.",
    "origin": "special form",
    "examples": [
      "(eval '(+ 1 2)) ; => 3"
    ]
  },
  {
    "name": "even?",
    "signature": "even? n",
    "doc": "Return true when the numeric argument is evenly divisible by two.",
    "origin": "core",
    "examples": [
      "(even? 4) ; => true",
      "(even? 3) ; => false"
    ]
  },
  {
    "name": "every?",
    "signature": "every? pred coll",
    "doc": "True when pred returns truthy for all items in coll. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(every? even? [2 4]) ; => true",
      "(every? [x [2 4]] (even? x)) ; => true"
    ]
  },
  {
    "name": "false?",
    "signature": "false? x",
    "doc": "True only for the literal false.",
    "origin": "core",
    "examples": [
      "(false? false) ; => true"
    ]
  },
  {
    "name": "ffirst",
    "signature": "ffirst coll",
    "doc": "Equivalent to (first (first coll)); returns nil when any level is missing.",
    "origin": "core",
    "examples": [
      "(ffirst [[1 2] [3 4]]) ; => 1",
      "(ffirst []) ; => nil"
    ]
  },
  {
    "name": "filter",
    "signature": "filter pred coll",
    "doc": "Return items from coll where pred yields truthy; stays lazy when coll is a seq. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(filter odd? [1 2 3 4]) ; => [1 3]",
      "(filter #{:a :c} [:b :a :d :c]) ; => [:a :c]",
      "(vec (filter [x [1 2 3 4]] (odd? x))) ; => [1 3]"
    ]
  },
  {
    "name": "find",
    "signature": "find map key",
    "doc": "Return the map entry for key or nil when absent.",
    "origin": "core",
    "examples": [
      "(find {:a 1 :b 2} :b) ; => [:b 2]",
      "(find {:a 1} :z) ; => nil"
    ]
  },
  {
    "name": "first",
    "signature": "first coll",
    "doc": "Return the first item of coll (nil if empty).",
    "origin": "core",
    "examples": [
      "(first [1 2]) ; => 1"
    ]
  },
  {
    "name": "flatten",
    "signature": "flatten coll\nflatten coll depth",
    "doc": "Flatten nested sequential structures into a vector. If depth is provided, flatten at most depth levels.",
    "origin": "core",
    "examples": [
      "(flatten [1 [2 [3 4]]]) ; => [1 2 3 4]",
      "(flatten [1 [2 [3 4]]] 1) ; => [1 2 [3 4]]",
      "(flatten [1 [2 [3 4]]] 2) ; => [1 2 3 4]",
      "(flatten [[:a] nil [:b :c]]) ; => [:a :b :c]"
    ]
  },
  {
    "name": "fn",
    "signature": "fn [params] body",
    "doc": "Create anonymous function.",
    "origin": "special form",
    "examples": [
      "(fn [x] (* x x)) ; => #<lambda>"
    ]
  },
  {
    "name": "fn-type",
    "signature": "fn-type f",
    "doc": "Return the inferred signature for a function value.",
    "origin": "core",
    "examples": [
      "(fn-type (fn [x] x)) ; => \"[a] -> a\"",
      "(fn-type #(str %)) ; => \"[Any] -> Str\""
    ]
  },
  {
    "name": "fn?",
    "signature": "fn? x",
    "doc": "True when the value is a function or lambda.",
    "origin": "core",
    "examples": [
      "(fn? (fn [] nil)) ; => true"
    ]
  },
  {
    "name": "fnil",
    "signature": "fnil f & defaults",
    "doc": "Return a function that replaces nil arguments with supplied defaults before calling f (supports up to three defaults).",
    "origin": "core",
    "examples": [
      "(let [f (fnil + 0 0)] (f nil 3)) ; => 3",
      "(let [f (fnil conj [])] (f nil :x)) ; => [:x]"
    ]
  },
  {
    "name": "for",
    "signature": "for [bindings] body",
    "doc": "List comprehension over the binding clauses, returning a sequence of body results.",
    "origin": "special form",
    "examples": [
      "(for [x [1 2 3]] (* x x)) ; => [1 4 9]",
      "(vec (for [x [1 2] y [:a :b]] [x y])) ; => [[1 :a] [1 :b] [2 :a] [2 :b]]"
    ]
  },
  {
    "name": "force",
    "signature": "force value",
    "doc": "Force a delay and return its value; non-delay values return as-is.",
    "origin": "core",
    "examples": [
      "(force (delay (+ 1 2))) ; => 3",
      "(force 10) ; => 10"
    ]
  },
  {
    "name": "format",
    "signature": "format template & args",
    "doc": "C-style formatting where {} uses pr-str and {:?} uses debug output.",
    "origin": "core",
    "examples": [
      "(format \"Hello {}\" :world) ; => \"Hello :world\"",
      "(format \"{:?}\" {:a 1}) ; => \"{:a 1}\""
    ]
  },
  {
    "name": "frequencies",
    "signature": "frequencies coll",
    "doc": "Return a map from item to occurrence count.",
    "origin": "core",
    "examples": [
      "(frequencies [:a :b :a]) ; => {:a 2 :b 1}",
      "(frequencies [1 1 2 3 3 3]) ; => {1 2 2 1 3 3}"
    ]
  },
  {
    "name": "future",
    "signature": "future callable [& opts]",
    "doc": "Run the zero-arity callable asynchronously and return a future handle; optional options maps are reserved for configuration.",
    "origin": "core",
    "examples": [
      "(future (fn [] (+ 1 2))) ; => #<future state=pending>",
      "(let [f (future (fn [] (inc 40)))] (future-deref f)) ; => 41"
    ]
  },
  {
    "name": "future-all",
    "signature": "future-all coll",
    "doc": "Return a future that waits for every promise/future/task in coll and yields a vector of their values.",
    "origin": "core",
    "examples": [
      "(future-deref (future-all [(future (fn [] 1)) (future (fn [] 2))])) ; => [1 2]",
      "(future-deref (future-all [])) ; => []"
    ]
  },
  {
    "name": "future-all-settled",
    "signature": "future-all-settled coll",
    "doc": "Return a future that resolves to vectors of {:status :fulfilled/:rejected, ...} describing every input promise/future/task.",
    "origin": "core",
    "examples": [
      "(future-deref (future-all-settled [(future (fn [] :ok))])) ; => [{:status :fulfilled :value :ok}]",
      "(future-deref (future-all-settled [(future (fn [] (throw (runtime-error \"boom\"))))])) ; => [{:status :rejected :error \"Runtime error: boom\"}]"
    ]
  },
  {
    "name": "future-any",
    "signature": "future-any coll",
    "doc": "Return a future that resolves with the first fulfilled value among the inputs (propagating an error if all reject).",
    "origin": "core",
    "examples": [
      "(future-deref (future-any [(future (fn [] :ok)) (future (fn [] :ok))])) ; => :ok",
      "(future-deref (future-any [(future (fn [] (throw (runtime-error \"fail\")))) (future (fn [] 1))])) ; => 1"
    ]
  },
  {
    "name": "future-cancel!",
    "signature": "future-cancel! future",
    "doc": "Request cancellation of the running future; returns true when the cancellation was applied before completion.",
    "origin": "core",
    "examples": [
      "(let [f (future (fn [] (time::sleep 1s) :done))] (future-cancel! f)) ; => true",
      "(let [f (future (fn [] 1))] (future-cancel! f)) ; => false"
    ]
  },
  {
    "name": "future-cancelled?",
    "signature": "future-cancelled? future",
    "doc": "True once the future has been cancelled.",
    "origin": "core",
    "examples": [
      "(let [f (future (fn [] (time::sleep 1s) :done))] (future-cancel! f) (future-cancelled? f)) ; => true",
      "(future-cancelled? (future (fn [] 1))) ; => false"
    ]
  },
  {
    "name": "future-catch",
    "signature": "future-catch source handler",
    "doc": "Return a future that uses handler to produce a value when source rejects; successful values pass through unchanged.",
    "origin": "core",
    "examples": [
      "(future-deref (future-catch (future (fn [] (throw (runtime-error \"boom\")))) (fn [_] :failed))) ; => :failed",
      "(future-deref (future-catch (future (fn [] 1)) (fn [_] :ignored))) ; => 1"
    ]
  },
  {
    "name": "future-deref",
    "signature": "future-deref future",
    "doc": "Block until the future completes and return its result, propagating errors.",
    "origin": "core",
    "examples": [
      "(future-deref (future (fn [] :done))) ; => :done",
      "(let [p (promise) f (future (fn [] (promise-deref p)))] (promise-deliver! p 10) (future-deref f)) ; => 10"
    ]
  },
  {
    "name": "future-done?",
    "signature": "future-done? future",
    "doc": "Return true once the future has completed or been cancelled.",
    "origin": "core",
    "examples": [
      "(let [p (promise) f (future (fn [] (promise-deref p)))] (future-done? f)) ; => false",
      "(let [p (promise) f (future (fn [] (promise-deref p)))] (promise-deliver! p :ok) (future-done? f)) ; => true"
    ]
  },
  {
    "name": "future-finally",
    "signature": "future-finally source f",
    "doc": "Return a future that invokes f (with no arguments) after source settles, yielding the original outcome.",
    "origin": "core",
    "examples": [
      "(future-deref (future-finally (future (fn [] 5)) (fn [] :cleanup))) ; => 5",
      "(let [flag (atom false) fut (future-finally (future (fn [] :ok)) (fn [] (atom-set! flag true)))] (future-deref fut) (atom-deref flag)) ; => true"
    ]
  },
  {
    "name": "future-race",
    "signature": "future-race coll",
    "doc": "Return a future that resolves or rejects with the first settled promise/future/task in coll.",
    "origin": "core",
    "examples": [
      "(future-deref (future-race [(future (fn [] :x)) (future (fn [] :y))])) ; => :x",
      "(future-deref (future-race [(future (fn [] 1))])) ; => 1"
    ]
  },
  {
    "name": "future-then",
    "signature": "future-then source f",
    "doc": "Return a future that applies f to the resolved value of the given future/promise/task.",
    "origin": "core",
    "examples": [
      "(future-deref (future-then (future (fn [] 1)) inc)) ; => 2",
      "(let [p (promise) chained (future-then p (fn [x] (* x 2)))] (promise-deliver! p 10) (future-deref chained)) ; => 20"
    ]
  },
  {
    "name": "future?",
    "signature": "future? value",
    "doc": "Return true when the value is a future handle.",
    "origin": "core",
    "examples": [
      "(future? (future (fn [] 1))) ; => true",
      "(future? 0) ; => false"
    ]
  },
  {
    "name": "gensym",
    "signature": "gensym\ngensym prefix",
    "doc": "Return a new unique symbol, optionally prefixed.",
    "origin": "core",
    "examples": [
      "(symbol? (gensym)) ; => true",
      "(string/starts-with? (str (gensym \"tmp\")) \"tmp\") ; => true"
    ]
  },
  {
    "name": "get",
    "signature": "get map key & [default]",
    "doc": "Lookup key in map, returning default if not present.",
    "origin": "core",
    "examples": [
      "(get {:a 1} :a) ; => 1"
    ]
  },
  {
    "name": "get-in",
    "signature": "get-in target path & [default]",
    "doc": "Traverse nested associative structures by path; returns default or nil when missing.",
    "origin": "core",
    "examples": [
      "(get-in {:a {:b 2}} [:a :b]) ; => 2"
    ]
  },
  {
    "name": "get-in-many",
    "signature": "get-in-many target paths & [default]",
    "doc": "Traverse multiple paths and return a vector of results; uses default or nil when missing.",
    "origin": "core",
    "examples": [
      "(get-in-many {:a {:b 2} :c 1} [[:a :b] [:c]]) ; => [2 1]",
      "(let [xs [[0 1] [2 3] [4 5]]]\n  (get-in-many xs [[1 0] [2 1]])) ; => [2 5]"
    ]
  },
  {
    "name": "go-loop",
    "signature": "go-loop [bindings] body",
    "doc": "Launch an asynchronous loop that supports channel operations.",
    "origin": "special form",
    "examples": [
      "(comment (go-loop [] (println \"tick\"))) ; => nil ; Launch an async loop"
    ]
  },
  {
    "name": "group-by",
    "signature": "group-by f coll",
    "doc": "Group coll into a map keyed by (f item). Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(group-by count [\"a\" \"bb\" \"c\"]) ; => {1 [\"a\" \"c\"] 2 [\"bb\"]}",
      "(group-by odd? [1 2 3 4]) ; => {true [1 3] false [2 4]}",
      "(group-by [x [1 2 3 4]] (odd? x)) ; => {true [1 3] false [2 4]}"
    ]
  },
  {
    "name": "hash",
    "signature": "hash value",
    "doc": "Return a hash code for value; map/set hashes are order-independent and reference types hash by identity.",
    "origin": "core",
    "examples": [
      "(integer? (hash :a)) ; => true",
      "(= (hash {:a 1 :b 2}) (hash {:b 2 :a 1})) ; => true"
    ]
  },
  {
    "name": "hash-map",
    "signature": "hash-map & kvs",
    "doc": "Create a map from the given key/value pairs (later pairs overwrite earlier).",
    "origin": "core",
    "examples": [
      "(hash-map :a 1 :b 2) ; => {:a 1 :b 2}"
    ]
  },
  {
    "name": "hash-set",
    "signature": "hash-set & values",
    "doc": "Create a set containing the distinct supplied values.",
    "origin": "core",
    "examples": [
      "(hash-set 1 2 2) ; => #{1 2}"
    ]
  },
  {
    "name": "http::delete",
    "signature": "http::delete url\nhttp::delete url opts",
    "doc": "Perform an HTTP DELETE request to url, optionally merging opts into the request. Returns the response map from http::request.",
    "origin": "http",
    "examples": [
      "(get (http::delete \"https://httpbin.org/delete\") :status) ; => 200"
    ]
  },
  {
    "name": "http::get",
    "signature": "http::get url\nhttp::get url opts",
    "doc": "Perform an HTTP GET request to url, optionally merging opts into the request. Returns the response map from http::request.",
    "origin": "http",
    "examples": [
      "(get (http::get \"https://httpbin.org/get\") :status) ; => 200"
    ]
  },
  {
    "name": "http::post",
    "signature": "http::post url\nhttp::post url opts",
    "doc": "Perform an HTTP POST request to url, optionally merging opts into the request. Returns the response map from http::request.",
    "origin": "http",
    "examples": [
      "(get (http::post \"https://httpbin.org/post\" {:json {:ping \"pong\"}}) :status) ; => 200"
    ]
  },
  {
    "name": "http::put",
    "signature": "http::put url\nhttp::put url opts",
    "doc": "Perform an HTTP PUT request to url, optionally merging opts into the request. Returns the response map from http::request.",
    "origin": "http",
    "examples": [
      "(get (http::put \"https://httpbin.org/put\" {:json {:ping \"pong\"}}) :status) ; => 200"
    ]
  },
  {
    "name": "http::request",
    "signature": "http::request opts-map",
    "doc": "Perform an HTTP request described by opts {:url :method :headers :query :json :body :timeout-ms}. Returns {:status code :headers map :body string :json value-or-nil}.",
    "origin": "http",
    "examples": [
      "(get (http::request {:url \"https://httpbin.org/get\"}) :status) ; => 200",
      "(-> {:url \"https://httpbin.org/post\" :method \"POST\" :json {:ping \"pong\"}} http::request :json :json) ; => {:ping \"pong\"}"
    ]
  },
  {
    "name": "identical?",
    "signature": "identical? a b",
    "doc": "True only when both arguments share the same identity (pointer-equal seqs/functions or equal scalars).",
    "origin": "core",
    "examples": [
      "(identical? 1 1) ; => true",
      "(identical? (seq [1 2]) (seq [1 2])) ; => false"
    ]
  },
  {
    "name": "identity",
    "signature": "identity x",
    "doc": "Return x without modification.",
    "origin": "core",
    "examples": [
      "(identity [1 2]) ; => [1 2]",
      "(map identity [nil false 3]) ; => [nil false 3]"
    ]
  },
  {
    "name": "tap",
    "signature": "tap f x",
    "doc": "Apply f to x for side effects, then return x.",
    "origin": "std",
    "examples": [
      "(tap inc 10) ; => 10",
      "(tap identity [1 2]) ; => [1 2]"
    ]
  },
  {
    "name": "each",
    "signature": "each [bindings] body",
    "doc": "Iterate for side effects across sequences of bindings; returns the first collection value.",
    "origin": "special form",
    "examples": [
      "(each [x [1 2]] (println \"x =\" x)) ; => [1 2] ; prints lines for each x",
      "(each [x [1 2] y [:a :b]] (println x y)) ; => [1 2] ; emits 4 pairs for side effects"
    ]
  },
  {
    "name": "std::each",
    "signature": "std::each f coll",
    "doc": "Apply f to each item in coll for side effects (eager). Returns coll.",
    "origin": "std",
    "examples": [
      "(std::each println [1 2]) ; => [1 2]",
      "(std::each (fn [x] (println x)) (range 2)) ; => [0 1]"
    ]
  },
  {
    "name": "run!",
    "signature": "run! f coll",
    "doc": "Apply f to each item in coll for side effects (eager). Returns nil. Supports [pat coll] sugar.",
    "origin": "std",
    "examples": [
      "(run! println [1 2]) ; => nil",
      "(run! (fn [x] (println x)) (range 2)) ; => nil",
      "(let [a (atom 0)] (run! [x [1 2 3]] (swap! a + x)) @a) ; => 6"
    ]
  },
  {
    "name": "if",
    "signature": "if test then else?",
    "doc": "Conditional expression.",
    "origin": "special form",
    "examples": [
      "(if true 1 2) ; => 1"
    ]
  },
  {
    "name": "if-let",
    "signature": "if-let [binding test] then else?",
    "doc": "Evaluate test; if truthy, bind and evaluate then, otherwise evaluate else.",
    "origin": "special form",
    "examples": [
      "(if-let [x 1] x 0) ; => 1"
    ]
  },
  {
    "name": "if-not",
    "signature": "if-not test then else?",
    "doc": "Evaluate then when test is falsy; otherwise evaluate else (default nil).",
    "origin": "special form",
    "examples": [
      "(if-not false :ok :ng) ; => :ok",
      "(if-not 1 :zero :nonzero) ; => :nonzero"
    ]
  },
  {
    "name": "if-some",
    "signature": "if-some [binding test] then else?",
    "doc": "Like if-let but treats only nil as falsey; false passes through.",
    "origin": "special form",
    "examples": [
      "(if-some [x 0] x 9) ; => 0"
    ]
  },
  {
    "name": "infer-type",
    "signature": "infer-type form",
    "doc": "Return the inferred static type for form without evaluating it.",
    "origin": "special form",
    "examples": [
      "(infer-type [1 2]) ; => \"[Int]\"",
      "(infer-type ([1 2]: [Int Int])) ; => \"[Int Int]\""
    ]
  },
  {
    "name": "inc",
    "signature": "inc n",
    "doc": "Increase the number by 1, preserving int/float shape.",
    "origin": "core",
    "examples": [
      "(inc 4) ; => 5",
      "(inc 2.5) ; => 3.5"
    ]
  },
  {
    "name": "includes?",
    "signature": "includes? coll x",
    "doc": "True when coll contains x. For strings, checks substring; for maps/sets, checks keys; for vectors/lists/seqs, checks values. Unlike contains?, which checks keys or indices.",
    "origin": "core",
    "examples": [
      "(includes? \"clove\" \"lo\") ; => true",
      "(includes? [:a :b :c] :b) ; => true",
      "(includes? [:a :b :c] :z) ; => false",
      "(includes? #{:a :b} :a) ; => true",
      "(includes? {:a 1 :b 2} :a) ; => true",
      "(includes? nil :a) ; => false"
    ]
  },
  {
    "name": "index-of",
    "signature": "index-of s substr [start]",
    "doc": "Return the index of the first occurrence of substr in s (or nil). Optional start skips that many characters.",
    "origin": "string",
    "examples": [
      "(index-of \"banana\" \"na\") ; => 2",
      "(index-of \"banana\" \"na\" 3) ; => 4"
    ]
  },
  {
    "name": "ini::generate",
    "signature": "ini::generate map",
    "doc": "Convert a nested map (section -> map of key -> value) into an INI-formatted string.",
    "origin": "config",
    "examples": [
      "(ini::generate {\"db\" {\"port\" 5432}}) ; => \"[db]\nport=5432\n\"",
      "(ini::generate {\"\" {\"debug\" true}}) ; => \"debug=true\n\""
    ]
  },
  {
    "name": "ini::parse",
    "signature": "ini::parse text",
    "doc": "Parse an INI string into a map of section names to maps of string values.",
    "origin": "config",
    "examples": [
      "(ini::parse \"[db]\nport=5432\n\") ; => {\"db\" {\"port\" \"5432\"}}",
      "(get (ini::parse \"debug=true\n\") \"\") ; => {\"debug\" \"true\"}"
    ]
  },
  {
    "name": "integer?",
    "signature": "integer? x",
    "doc": "True for integral numbers (ints or floats with zero fractional part).",
    "origin": "core",
    "examples": [
      "(integer? 2) ; => true"
    ]
  },
  {
    "name": "instance?",
    "signature": "instance? type value",
    "doc": "Return true when value conforms to the given type name (symbol/keyword or string), validating required fields for deftype values.",
    "origin": "core",
    "examples": [
      "(instance? :core::Int 1) ; => true",
      "(instance? \"core::Str\" :name) ; => false"
    ]
  },
  {
    "name": "interleave",
    "signature": "interleave [& colls]",
    "doc": "Interleave items from each collection element-wise until the shortest runs out.",
    "origin": "core",
    "examples": [
      "(interleave [1 2] [:a :b]) ; => [1 :a 2 :b]",
      "(interleave (list \"x\" \"y\") [10 20]) ; => [\"x\" 10 \"y\" 20]"
    ]
  },
  {
    "name": "interpose",
    "signature": "interpose sep coll",
    "doc": "Insert sep between every pair of items in coll, returning a vector.",
    "origin": "core",
    "examples": [
      "(interpose :/ [:a :b :c]) ; => [:a :/ :b :/ :c]",
      "(interpose 0 [1 2]) ; => [1 0 2]"
    ]
  },
  {
    "name": "into",
    "signature": "into to-coll from-coll",
    "doc": "Conjoin each value from from-coll onto to-coll, preserving the target type.",
    "origin": "core",
    "examples": [
      "(into [1 2] (list 3 4)) ; => [1 2 3 4]",
      "(into {} [[:a 1] [:b 2]]) ; => {:a 1 :b 2}"
    ]
  },
  {
    "name": "iterate",
    "signature": "iterate f x",
    "doc": "Return a lazy seq of x, (f x), (f (f x)), ...",
    "origin": "core",
    "examples": [
      "(vec (take 4 (iterate inc 0))) ; => [0 1 2 3]",
      "(take 3 (iterate #(+ % 2) 1)) ; => [1 3 5]"
    ]
  },
  {
    "name": "string::join",
    "signature": "join coll\njoin coll sep",
    "doc": "Join the items of coll into a single string, optionally inserting separator between items.",
    "origin": "string",
    "examples": [
      "(string::join [\"a\" \"b\" \"c\"]) ; => \"abc\"",
      "(string::join [:a :b] \", \") ; => \":a, :b\""
    ]
  },
  {
    "name": "json::generate",
    "signature": "json::generate value",
    "doc": "Encode the value into compact JSON text and return it as a string.",
    "origin": "json",
    "examples": [
      "(json::generate {:a 1}) ; => \"{\"a\":1}\"",
      "(json::generate [1 2 3]) ; => \"[1,2,3]\""
    ]
  },
  {
    "name": "json::generate-pretty",
    "signature": "json::generate-pretty value",
    "doc": "Encode the value into pretty-printed JSON text (with indentation).",
    "origin": "json",
    "examples": [
      "(json::generate-pretty {:a 1}) ; => \"{\n  \"a\": 1\n}\"",
      "(json::generate-pretty [1]) ; => \"[\n  1\n]\""
    ]
  },
  {
    "name": "json::parse",
    "signature": "json::parse text",
    "doc": "Parse JSON text into the corresponding Clove value.",
    "origin": "json",
    "examples": [
      "(json::parse \"[1,2]\") ; => [1 2]",
      "(json::parse \"{\\\"ok\\\":true}\") ; => {\"ok\" true}"
    ]
  },
  {
    "name": "json::read-file",
    "signature": "json::read-file path",
    "doc": "Read a file from disk and parse it as JSON.",
    "origin": "json",
    "examples": [
      "(json::read-file \"data::fixtures/json/example.json\") ; => {\"items\" [{\"id\" 1 \"name\" \"alpha\"} {\"id\" 2 \"name\" \"beta\"}]}",
      "(map? (json::read-file \"data::fixtures/json/example.json\")) ; => true"
    ]
  },
  {
    "name": "json::read-file-seq",
    "signature": "json::read-file-seq path",
    "doc": "Read a JSON file lazily. Arrays yield elements; objects yield [key value] pairs.",
    "origin": "json",
    "examples": [
      "(first (json::read-file-seq \"data::fixtures/json/example.json\")) ; => [\"items\" [{\"id\" 1 \"name\" \"alpha\"} {\"id\" 2 \"name\" \"beta\"}]]",
      "(seq? (json::read-file-seq \"data::fixtures/json/example.json\")) ; => true"
    ]
  },
  {
    "name": "json::write-file",
    "signature": "json::write-file path value",
    "doc": "Write value to the file at path as JSON text (returns path).",
    "origin": "json",
    "examples": [
      "(json::write-file \"tmp/out.json\" {:ok true}) ; => \"tmp/out.json\"",
      "(json::write-file \"tmp/list.json\" [1 2 3]) ; => \"tmp/list.json\""
    ]
  },
  {
    "name": "juxt",
    "signature": "juxt & fns",
    "doc": "Return a function that applies each fn to the same args and collects the results.",
    "origin": "core",
    "examples": [
      "((juxt inc dec str) 10) ; => [11 9 \"10\"]",
      "((juxt first count) [1 2 3]) ; => [1 3]"
    ]
  },
  {
    "name": "keep",
    "signature": "keep pred coll",
    "doc": "Return a lazy seq of non-nil results from applying pred to each item. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(keep #(when (even? %) (/ % 2)) [1 2 3 4]) ; => [1 2]",
      "(vec (keep first [[1 2] [nil 3] [4 5]])) ; => [1 4]",
      "(vec (keep [x [1 2 3 4]] (if (even? x) (/ x 2) nil))) ; => [1 2]"
    ]
  },
  {
    "name": "keep-indexed",
    "signature": "keep-indexed pred coll",
    "doc": "Like keep but pred receives index and item.",
    "origin": "core",
    "examples": [
      "(keep-indexed (fn [i x] (when (even? i) x)) [:a :b :c]) ; => [:a :c]",
      "(vec (keep-indexed (fn [i x] (when (= i x) x)) [0 1 0 3])) ; => [0 1 3]"
    ]
  },
  {
    "name": "key",
    "signature": "key entry",
    "doc": "Return the key from a map entry (vector/list of at least 2 items).",
    "origin": "core",
    "examples": [
      "(key [:a 1]) ; => :a",
      "(key (find {:a 1} :a)) ; => :a"
    ]
  },
  {
    "name": "keys",
    "signature": "keys [m]",
    "doc": "Return the keys of a map as a sequence.",
    "origin": "core",
    "examples": [
      "(vec (sort (keys {:a 1 :b 2}))) ; => [:a :b]"
    ]
  },
  {
    "name": "keyword",
    "signature": "keyword x\nkeyword ns name",
    "doc": "Create a keyword from string/symbol input, or namespace/name pair.",
    "origin": "core",
    "examples": [
      "(keyword \"user\") ; => :user",
      "(keyword \"ns\" \"name\") ; => :ns::name"
    ]
  },
  {
    "name": "keyword?",
    "signature": "keyword? x",
    "doc": "True when the value is a keyword.",
    "origin": "core",
    "examples": [
      "(keyword? :a) ; => true"
    ]
  },
  {
    "name": "walk::keywordize-keys",
    "signature": "keywordize-keys form",
    "doc": "Walk the data structure converting string map keys into keywords.",
    "origin": "walk",
    "examples": [
      "(walk::keywordize-keys {\"user\" {\"name\" \"Ada\"}}) ; => {:user {:name \"Ada\"}}",
      "(walk::keywordize-keys [{\"a\" 1} {\"b\" 2}]) ; => [{:a 1} {:b 2}]"
    ]
  },
  {
    "name": "last",
    "signature": "last coll",
    "doc": "Return the last item of coll.",
    "origin": "core",
    "examples": [
      "(last [1 2 3]) ; => 3"
    ]
  },
  {
    "name": "last-index-of",
    "signature": "last-index-of s substr [end]",
    "doc": "Return the index of the last occurrence of substr in s (or nil). Optional end limits the search to the first end characters.",
    "origin": "string",
    "examples": [
      "(last-index-of \"banana\" \"na\") ; => 4",
      "(last-index-of \"banana\" \"z\") ; => nil"
    ]
  },
  {
    "name": "let",
    "signature": "let [bindings] body",
    "doc": "Lexical bindings.",
    "origin": "special form",
    "examples": [
      "(let [x 1 y 2] (+ x y)) ; => 3"
    ]
  },
  {
    "name": "list",
    "signature": "list & values",
    "doc": "Create a list (linked) containing the supplied values.",
    "origin": "core",
    "examples": [
      "(list 1 2 3) ; => (1 2 3)"
    ]
  },
  {
    "name": "list?",
    "signature": "list? x",
    "doc": "True when the value is a list.",
    "origin": "core",
    "examples": [
      "(list? (list 1)) ; => true"
    ]
  },
  {
    "name": "load-file",
    "signature": "load-file path",
    "doc": "Read and evaluate the forms in the file at path.",
    "origin": "special form",
    "examples": [
      "(comment (load-file \"examples/hello.clv\")) ; => nil ; Load and eval a file at runtime"
    ]
  },
  {
    "name": "load-string",
    "signature": "load-string source",
    "doc": "Read and evaluate all forms in the source string; returns the last result.",
    "origin": "special form",
    "examples": [
      "(load-string \"(+ 1 2)\") ; => 3",
      "(load-string \"(+ 1 2) (+ 3 4)\") ; => 7"
    ]
  },
  {
    "name": "long",
    "signature": "long n",
    "doc": "Convert the number to a 64-bit integer by truncating toward zero.",
    "origin": "core",
    "examples": [
      "(long 3.9) ; => 3",
      "(long -2.1) ; => -2"
    ]
  },
  {
    "name": "lookup",
    "signature": "lookup query & selectors",
    "doc": "Alias of nav; unified search across namespaces, vars, and docs.",
    "origin": "special form",
    "examples": [
      "(lookup \"disj\") ; => {:kind :nav ...}",
      "(lookup /take|drop/ :var :doc) ; => {:kind :nav ...}"
    ]
  },
  {
    "name": "loop",
    "signature": "loop [bindings] body",
    "doc": "Create a recursion point with initial bindings for recur.",
    "origin": "special form",
    "examples": [
      "(loop [n 3 acc 0] (if (zero? n) acc (recur (dec n) (+ acc n)))) ; => 6"
    ]
  },
  {
    "name": "lower-case",
    "signature": "lower-case [s]",
    "doc": "Return the lower-case form of the string.",
    "origin": "string",
    "examples": [
      "(lower-case \"CLOVE\") ; => \"clove\"",
      "(lower-case \"MiXeD\") ; => \"mixed\""
    ]
  },
  {
    "name": "map",
    "signature": "map f coll",
    "doc": "Apply f across items from each collection in lockstep; stops at the shortest and is lazy when any input is a seq. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(map inc [1 2 3]) ; => [2 3 4]",
      "(map + [1 2 3] [10 20 30]) ; => [11 22 33]",
      "(map #0 [[1 2] [3 4]]) ; => [1 3]",
      "(vec (map [x [1 2 3]] (+ x 1))) ; => [2 3 4]"
    ]
  },
  {
    "name": "map-indexed",
    "signature": "map-indexed f coll",
    "doc": "Map across the collection, passing the current zero-based index as the first argument; returns a lazy seq when possible.",
    "origin": "core",
    "examples": [
      "(vec (map-indexed (fn [i v] [i v]) [:a :b])) ; => [[0 :a] [1 :b]]",
      "(first (map-indexed (fn [i v] (+ i v)) (range 1 4))) ; => 1"
    ]
  },
  {
    "name": "map?",
    "signature": "map? x",
    "doc": "True when the value is a map.",
    "origin": "core",
    "examples": [
      "(map? {:a 1}) ; => true"
    ]
  },
  {
    "name": "mapcat",
    "signature": "mapcat f coll & colls",
    "doc": "Apply f across the provided colls and concat each intermediate result.",
    "origin": "core",
    "examples": [
      "(mapcat #(vector % %) [1 2]) ; => [1 1 2 2]",
      "(mapcat (fn [i ch] [i ch]) [1 2] [:a :b]) ; => [1 :a 2 :b]"
    ]
  },
  {
    "name": "match",
    "signature": "match value & clauses",
    "doc": "Pattern match value against clauses, returning the first matching result. Clauses are pairs of pattern and result expressions; _ is the catch-all pattern. Patterns support OR with '|' or ','.",
    "origin": "special form",
    "examples": [
      "(do (deftype KeyEvent {:key Str}) (deftype TickEvent {:time Int}) (match (KeyEvent {:key \"a\"}) (KeyEvent {:key,}) key (TickEvent {:time,}) time _ :other)) ; => \"a\"",
      "(match 1 0 :zero 1 :one _ :other) ; => :one",
      "(match 2 1,2,3 :hit _ :miss) ; => :hit",
      "(match 2 1 | 2 | 3 :hit _ :miss) ; => :hit",
      "(do (deftype KeyEvent {:key Str}) (match (KeyEvent {:key \"x\"}) (KeyEvent {:key k}) :when (= k \"x\") k _ :miss)) ; => \"x\""
    ]
  },
  {
    "name": "math::E",
    "signature": "math::E",
    "doc": "Euler's number (base of natural logarithms).",
    "origin": "math",
    "examples": [
      "math::E ; => 2.718281828459045"
    ]
  },
  {
    "name": "math::PI",
    "signature": "math::PI",
    "doc": "Pi constant.",
    "origin": "math",
    "examples": [
      "math::PI ; => 3.141592653589793"
    ]
  },
  {
    "name": "math::sin",
    "signature": "math::sin x",
    "doc": "Return the sine of x (radians).",
    "origin": "math",
    "examples": [
      "(math::sin 0) ; => 0.0"
    ]
  },
  {
    "name": "math::cos",
    "signature": "math::cos x",
    "doc": "Return the cosine of x (radians).",
    "origin": "math",
    "examples": [
      "(math::cos 0) ; => 1.0"
    ]
  },
  {
    "name": "math::tan",
    "signature": "math::tan x",
    "doc": "Return the tangent of x (radians).",
    "origin": "math",
    "examples": [
      "(math::tan 0) ; => 0.0"
    ]
  },
  {
    "name": "math::asin",
    "signature": "math::asin x",
    "doc": "Return the arcsine of x (radians).",
    "origin": "math",
    "examples": [
      "(math::asin 0) ; => 0.0"
    ]
  },
  {
    "name": "math::acos",
    "signature": "math::acos x",
    "doc": "Return the arccosine of x (radians).",
    "origin": "math",
    "examples": [
      "(math::acos 1) ; => 0.0"
    ]
  },
  {
    "name": "math::atan",
    "signature": "math::atan x",
    "doc": "Return the arctangent of x (radians).",
    "origin": "math",
    "examples": [
      "(math::atan 0) ; => 0.0"
    ]
  },
  {
    "name": "math::atan2",
    "signature": "math::atan2 y x",
    "doc": "Return the arctangent of y/x, using the signs to determine the quadrant.",
    "origin": "math",
    "examples": [
      "(math::atan2 0 1) ; => 0.0"
    ]
  },
  {
    "name": "math::exp",
    "signature": "math::exp x",
    "doc": "Return e raised to x.",
    "origin": "math",
    "examples": [
      "(math::exp 0) ; => 1.0"
    ]
  },
  {
    "name": "math::log",
    "signature": "math::log x",
    "doc": "Return the natural logarithm of x.",
    "origin": "math",
    "examples": [
      "(math::log 1) ; => 0.0"
    ]
  },
  {
    "name": "math::log10",
    "signature": "math::log10 x",
    "doc": "Return the base-10 logarithm of x.",
    "origin": "math",
    "examples": [
      "(math::log10 1) ; => 0.0"
    ]
  },
  {
    "name": "math::expm1",
    "signature": "math::expm1 x",
    "doc": "Return exp(x) - 1 with better precision for small x.",
    "origin": "math",
    "examples": [
      "(math::expm1 0) ; => 0.0"
    ]
  },
  {
    "name": "math::log1p",
    "signature": "math::log1p x",
    "doc": "Return log(1 + x) with better precision for small x.",
    "origin": "math",
    "examples": [
      "(math::log1p 0) ; => 0.0"
    ]
  },
  {
    "name": "math::pow",
    "signature": "math::pow base exp",
    "doc": "Return base raised to exp.",
    "origin": "math",
    "examples": [
      "(math::pow 2 3) ; => 8.0"
    ]
  },
  {
    "name": "math::sqrt",
    "signature": "math::sqrt x",
    "doc": "Return the square root of x.",
    "origin": "math",
    "examples": [
      "(math::sqrt 9) ; => 3.0"
    ]
  },
  {
    "name": "math::cbrt",
    "signature": "math::cbrt x",
    "doc": "Return the cube root of x.",
    "origin": "math",
    "examples": [
      "(math::cbrt 8) ; => 2.0"
    ]
  },
  {
    "name": "math::hypot",
    "signature": "math::hypot x y",
    "doc": "Return sqrt(x^2 + y^2) without undue overflow or underflow.",
    "origin": "math",
    "examples": [
      "(math::hypot 3 4) ; => 5.0"
    ]
  },
  {
    "name": "math::floor",
    "signature": "math::floor x",
    "doc": "Return the largest integer <= x as a float.",
    "origin": "math",
    "examples": [
      "(math::floor 1.9) ; => 1.0"
    ]
  },
  {
    "name": "math::ceil",
    "signature": "math::ceil x",
    "doc": "Return the smallest integer >= x as a float.",
    "origin": "math",
    "examples": [
      "(math::ceil 1.1) ; => 2.0"
    ]
  },
  {
    "name": "math::round",
    "signature": "math::round x",
    "doc": "Round to the nearest integer (ties away from zero).",
    "origin": "math",
    "examples": [
      "(math::round 1.4) ; => 1"
    ]
  },
  {
    "name": "math::rint",
    "signature": "math::rint x",
    "doc": "Round to the nearest integer using ties-to-even.",
    "origin": "math",
    "examples": [
      "(math::rint 2.5) ; => 2.0"
    ]
  },
  {
    "name": "math::to-radians",
    "signature": "math::to-radians degrees",
    "doc": "Convert degrees to radians.",
    "origin": "math",
    "examples": [
      "(math::to-radians 180) ; => 3.141592653589793"
    ]
  },
  {
    "name": "math::to-degrees",
    "signature": "math::to-degrees radians",
    "doc": "Convert radians to degrees.",
    "origin": "math",
    "examples": [
      "(math::to-degrees 0) ; => 0.0"
    ]
  },
  {
    "name": "max",
    "signature": "max x & more",
    "doc": "Return the largest of the numeric arguments (at least one argument required).",
    "origin": "core",
    "examples": [
      "(max 3 10 4) ; => 10",
      "(max -2 -7) ; => -2"
    ]
  },
  {
    "name": "max-key",
    "signature": "max-key key-fn value & more",
    "doc": "Apply key-fn to each candidate and return the value whose key is greatest.",
    "origin": "core",
    "examples": [
      "(max-key count [1] [1 2 3]) ; => [1 2 3]",
      "(max-key first [5 2] [1 9]) ; => [5 2]"
    ]
  },
  {
    "name": "memo",
    "signature": "memo f [opts]",
    "doc": "Return a memoized version of the callable f. Optional opts {:store path :ttl duration} configure persistence and expiration.",
    "origin": "core",
    "examples": [
      "(let [calls (atom 0) m (memo (fn [x] (swap! calls inc) (* x x)))] [(m 3) (m 3) (atom-deref calls)]) ; => [9 9 1]",
      "(let [m (memo (fn [x] (+ x 10)) {:ttl 1s})] (m 1)) ; => 11"
    ]
  },
  {
    "name": "memoize",
    "signature": "memoize f",
    "doc": "Wrap the function with an in-memory cache keyed by argument list (optionally persistent via memo).",
    "origin": "core",
    "examples": [
      "(let [m (memoize (fn [x] (* x x)))] (m 5)) ; => 25",
      "(let [m (memoize (fn [x] (+ x 10)))] (= (m 2) (m 2))) ; => true"
    ]
  },
  {
    "name": "merge",
    "signature": "merge & maps",
    "doc": "Combine maps left-to-right; later maps override earlier keys.",
    "origin": "core",
    "examples": [
      "(merge {:a 1} {:b 2}) ; => {:a 1 :b 2}"
    ]
  },
  {
    "name": "merge!",
    "signature": "merge! m & maps",
    "doc": "Destructively merge maps into a mutable map.",
    "origin": "core",
    "examples": [
      "(let [m (mut {:a 1})]\n  (merge! m {:b 2} {:a 3})\n  m) ; => #<mut {:a 3 :b 2}>"
    ]
  },
  {
    "name": "merge-with",
    "signature": "merge-with f & maps",
    "doc": "Merge maps left-to-right, combining duplicate keys with f.",
    "origin": "core",
    "examples": [
      "(merge-with + {:a 1 :b 2} {:a 3 :c 4}) ; => {:a 4 :b 2 :c 4}",
      "(merge-with into {:tags #{:a}} {:tags #{:b :c}}) ; => {:tags #{:a :b :c}}"
    ]
  },
  {
    "name": "meta",
    "signature": "meta value",
    "doc": "Return the metadata map attached to the value (or nil when none).",
    "origin": "core",
    "examples": [
      "(meta (with-meta [1] {:tag :vec})) ; => {:tag :vec}",
      "(meta 10) ; => nil"
    ]
  },
  {
    "name": "min",
    "signature": "min x & more",
    "doc": "Return the smallest of the numeric arguments (at least one argument required).",
    "origin": "core",
    "examples": [
      "(min 3 10 4) ; => 3",
      "(min -2 -7) ; => -7"
    ]
  },
  {
    "name": "min-key",
    "signature": "min-key key-fn value & more",
    "doc": "Apply key-fn to each candidate and return the value whose key is smallest.",
    "origin": "core",
    "examples": [
      "(min-key count [1] [1 2 3] [1 2]) ; => [1]",
      "(min-key first [5 2] [1 9]) ; => [1 9]"
    ]
  },
  {
    "name": "mod",
    "signature": "mod num div",
    "doc": "Euclidean remainder of num divided by div (divisor zero raises).",
    "origin": "core",
    "examples": [
      "(mod 5 3) ; => 2",
      "(mod -3 2) ; => 1"
    ]
  },
  {
    "name": "nav",
    "signature": "nav query & selectors",
    "doc": "Unified search across namespaces, vars, and docs with a single API.",
    "origin": "special form",
    "examples": [
      "(nav 'disj) ; => {:kind :nav ...}",
      "(nav 'disj :var) ; => {:kind :nav ...}",
      "(nav /take|drop/ :var :doc) ; => {:kind :nav ...}"
    ]
  },
  {
    "name": "next",
    "signature": "next coll",
    "doc": "Return the tail of coll as a seq, or nil when there are zero/one items.",
    "origin": "core",
    "examples": [
      "(next [1 2 3]) ; => (2 3)"
    ]
  },
  {
    "name": "nil?",
    "signature": "nil? x",
    "doc": "True only when the value is nil.",
    "origin": "core",
    "examples": [
      "(nil? nil) ; => true"
    ]
  },
  {
    "name": "not",
    "signature": "not x",
    "doc": "Return true if x is falsy, false otherwise.",
    "origin": "core",
    "examples": [
      "(not true) ; => false"
    ]
  },
  {
    "name": "not-empty",
    "signature": "not-empty coll",
    "doc": "Return coll when it contains items; return nil when empty.",
    "origin": "core",
    "examples": [
      "(not-empty [1]) ; => [1]",
      "(not-empty []) ; => nil"
    ]
  },
  {
    "name": "not-any?",
    "signature": "not-any? pred coll",
    "doc": "Return true when pred returns falsey for every item. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(not-any? pos? [-1 -2]) ; => true",
      "(not-any? odd? [2 4 5]) ; => false",
      "(not-any? [x [-1 -2]] (pos? x)) ; => true"
    ]
  },
  {
    "name": "not-every?",
    "signature": "not-every? pred coll",
    "doc": "Return true when some element of coll fails the predicate. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(not-every? even? [2 4 5]) ; => true",
      "(not-every? odd? [1 3]) ; => false",
      "(not-every? [x [-1 0 1]] (neg? x)) ; => true"
    ]
  },
  {
    "name": "not=",
    "signature": "not= x y",
    "doc": "Return true when any of the arguments differ.",
    "origin": "core",
    "examples": [
      "(not= 1 2) ; => true"
    ]
  },
  {
    "name": "ns",
    "signature": "ns name doc? attr-map? & opts",
    "doc": "Declare or switch namespace. Optional docstring and attr-map may appear after the name in any order.",
    "origin": "special form",
    "examples": [
      "(ns demo.core) ; => demo.core",
      "(ns tools.math) ; => tools.math"
    ]
  },
  {
    "name": "ns-map",
    "signature": "ns-map [name]",
    "doc": "Return a map of symbols defined in the namespace.",
    "origin": "special form",
    "examples": [
      "(comment (ns-map 'app::core)) ; => nil ; Return a map of symbols in a namespace"
    ]
  },
  {
    "name": "nth",
    "signature": "nth coll index [default]",
    "doc": "Return the element at the zero-based index, or default (nil when omitted) when out of range. Index may be a number or an index collection (vector/list), in which case a vector of results is returned.",
    "origin": "core",
    "examples": [
      "(nth [10 20 30] 1) ; => 20",
      "(nth [0] 5 :miss) ; => :miss",
      "(nth [10 20 30 40] [1 3]) ; => [20 40]",
      "(nth [10 20 30] [0 99 2] nil) ; => [10 nil 30]"
    ]
  },
  {
    "name": "number?",
    "signature": "number? x",
    "doc": "Returns true for ints or floats.",
    "origin": "core",
    "examples": [
      "(number? 1.5) ; => true"
    ]
  },
  {
    "name": "odd?",
    "signature": "odd? n",
    "doc": "Return true when the numeric argument is odd.",
    "origin": "core",
    "examples": [
      "(odd? 3) ; => true",
      "(odd? 4) ; => false"
    ]
  },
  {
    "name": "or",
    "signature": "or expr*",
    "doc": "Short-circuiting logical disjunction.",
    "origin": "special form",
    "examples": [
      "(or false :a) ; => :a"
    ]
  },
  {
    "name": "partial",
    "signature": "partial f & args",
    "doc": "Return a new function that pre-fills args and delegates to f when called.",
    "origin": "core",
    "examples": [
      "(partial + 1) ; => #<partial + args=[1] remaining=any>"
    ]
  },
  {
    "name": "partition",
    "signature": null,
    "doc": null,
    "origin": null,
    "examples": [
      "(partition 3 [1 2 3 4 5 6]) ; => [[1 2 3] [4 5 6]]",
      "(partition 2 1 [1 2 3 4]) ; => [[1 2] [2 3] [3 4]]"
    ]
  },
  {
    "name": "partition-all",
    "signature": "partition-all n coll\npartition-all n step coll",
    "doc": "Partition coll into vectors of up to n items, keeping the tail chunk; optional step advances the window.",
    "origin": "core",
    "examples": [
      "(partition-all 3 [1 2 3 4 5]) ; => [[1 2 3] [4 5]]",
      "(partition-all 2 1 [:a :b :c]) ; => [[:a :b] [:b :c] [:c]]"
    ]
  },
  {
    "name": "partition-by",
    "signature": "partition-by f coll",
    "doc": "Split coll whenever (f item) changes, returning vectors of contiguous runs. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(partition-by odd? [1 3 2 4 5]) ; => [[1 3] [2 4] [5]]",
      "(partition-by identity [\"a\" \"a\" \"b\"]) ; => [[\"a\" \"a\"] [\"b\"]]",
      "(partition-by [x [\"a\" \"a\" \"b\"]] x) ; => [[\"a\" \"a\"] [\"b\"]]"
    ]
  },
  {
    "name": "peek",
    "signature": "peek coll",
    "doc": "For lists return the first element, for vectors return the last, for seqs return the next element; nil for empty collections.",
    "origin": "core",
    "examples": [
      "(peek [1 2 3]) ; => 3",
      "(peek (list 1 2 3)) ; => 1"
    ]
  },
  {
    "name": "pipe",
    "signature": "pipe f & more",
    "doc": "Compose functions left-to-right; the first function receives the original args, subsequent ones receive the previous result.",
    "origin": "core",
    "examples": [
      "(let [f (pipe inc #(* % 2))] (f 3)) ; => 8",
      "(let [f (pipe vector count)] (f 42)) ; => 1"
    ]
  },
  {
    "name": "pfilter",
    "signature": "pfilter pred coll\npfilter pred coll opts\npfilter opts pred coll\npfilter [x coll] body\npfilter [x coll] opts body\npfilter opts [x coll] body",
    "doc": "Parallel filter using fixed workers and chunked execution; opts: :workers/:chunk/:buffer/:ordered?/:on-error (alias: :max-parallel).",
    "origin": "core",
    "examples": [
      "(pfilter odd? [1 2 3 4]) ; => [1 3]",
      "(pfilter {:workers 2} odd? [1 2 3 4]) ; => [1 3]",
      "(pfilter [x [1 2 3 4]] {:workers 2} (odd? x)) ; => [1 3]"
    ]
  },
  {
    "name": "pmap",
    "signature": "pmap f coll\npmap f coll opts\npmap opts f coll\npmap [x coll] body\npmap [x coll] opts body\npmap opts [x coll] body",
    "doc": "Parallel map using fixed workers and chunked execution; opts: :workers/:chunk/:buffer/:ordered?/:on-error (alias: :max-parallel).",
    "origin": "core",
    "examples": [
      "(vec (pmap inc [1 2 3])) ; => [2 3 4]",
      "(vec (pmap {:workers 2} inc [1 2 3])) ; => [2 3 4]",
      "(pmap [x [1 2 3]] (+ x 1)) ; => [2 3 4]",
      "(pmap {:workers 2} [x [1 2 3]] (+ x 1)) ; => [2 3 4]"
    ]
  },
  {
    "name": "std::pfilter",
    "signature": "std::pfilter pred coll\nstd::pfilter pred coll opts\nstd::pfilter opts pred coll\nstd::pfilter [x coll] body\nstd::pfilter [x coll] opts body\nstd::pfilter opts [x coll] body",
    "doc": "Alias of dag::pfilter.",
    "origin": "std",
    "examples": [
      "(std::pfilter odd? [1 2 3 4]) ; => [1 3]"
    ]
  },
  {
    "name": "std::pmap",
    "signature": "std::pmap f coll\nstd::pmap f coll opts\nstd::pmap opts f coll\nstd::pmap [x coll] body\nstd::pmap [x coll] opts body\nstd::pmap opts [x coll] body",
    "doc": "Alias of dag::pmap.",
    "origin": "std",
    "examples": [
      "(vec (std::pmap inc [1 2 3])) ; => [2 3 4]"
    ]
  },
  {
    "name": "pos?",
    "signature": "pos? n",
    "doc": "Return true when the number is greater than zero.",
    "origin": "core",
    "examples": [
      "(pos? 3) ; => true",
      "(pos? -1) ; => false"
    ]
  },
  {
    "name": "walk::postwalk",
    "signature": "postwalk f form",
    "doc": "Depth-first walk of form applying f after processing children.",
    "origin": "walk",
    "examples": [
      "(walk::postwalk (fn [x] (if (keyword? x) (name x) x)) {:a {:b 1}}) ; => {\"a\" {\"b\" 1}}",
      "(walk::postwalk (fn [x] (if (number? x) (* x 10) x)) [1 {:x 2}]) ; => [10 {:x 20}]"
    ]
  },
  {
    "name": "pr-str",
    "signature": "pr-str & values",
    "doc": "Return the pr-str representation of the given values as a single string.",
    "origin": "core",
    "examples": [
      "(pr-str [1 2 3]) ; => \"\\\"[1 2 3]\\\"\" ; Return a string"
    ]
  },
  {
    "name": "pp-str",
    "signature": "pp-str x\npp-str x opts",
    "doc": "Return the pretty-printed readable representation of x as a string. Reads clovefmt.toml or .clovefmt.toml from the current directory for indent/width unless overridden by opts {:indent :width}. Limits {:max-depth :max-items :max-string :max-bytes} apply while rendering; non-literal values are stringified to keep output parseable.",
    "origin": "core",
    "examples": [
      "(pp-str {:a 1 :b [1 2 3 {:c 4}]}) ; => \"{:a 1 :b [1 2 3 {:c 4}]}\"",
      "(pp-str {:a [1 2 3 4 5 6]} {:max-items 3}) ; => \"{:a [1 2 3 ...]}\""
    ]
  },
  {
    "name": "pp",
    "signature": "pp x\npp x opts",
    "doc": "Pretty-print x to *out* and return x. Uses the same opts as pp-str for indent/width and limits.",
    "origin": "core",
    "examples": [
      "(comment (pp {:a 1 :b [1 2 3 {:c 4}]})) ; => {:a 1 :b [1 2 3 {:c 4}]} ; Pretty-print value",
      "(comment (pp {:a [1 2 3 4 5 6]} {:max-items 3})) ; => {:a [1 2 3 ...]} ; Pretty-print with limits"
    ]
  },
  {
    "name": "pprint-str",
    "signature": "pprint-str x\npprint-str x opts",
    "doc": "Alias of pp-str.",
    "origin": "core",
    "examples": [
      "(pprint-str {:a 1 :b 2}) ; => \"{:a 1 :b 2}\""
    ]
  },
  {
    "name": "pprint",
    "signature": "pprint x\npprint x opts",
    "doc": "Alias of pp.",
    "origin": "core",
    "examples": [
      "(comment (pprint {:a 1 :b 2})) ; => {:a 1 :b 2} ; Pretty-print value"
    ]
  },
  {
    "name": "walk::prewalk",
    "signature": "prewalk f form",
    "doc": "Depth-first walk of form applying f before visiting children.",
    "origin": "walk",
    "examples": [
      "(walk::prewalk (fn [x] (if (map? x) (assoc x :visited true) x)) {:a {:b 1}}) ; => {:a {:b 1 :visited true} :visited true}",
      "(walk::prewalk (fn [x] (if (number? x) (* x 2) x)) [1 {:x 2}]) ; => [2 {:x 4}]"
    ]
  },
  {
    "name": "print",
    "signature": "print & values",
    "doc": "Print each value without a trailing newline.",
    "origin": "core",
    "examples": [
      "(comment (print \"hello\" 42)) ; => nil ; Print without a trailing newline"
    ]
  },
  {
    "name": "printf",
    "signature": "printf format & args",
    "doc": "Format the string using printf-style placeholders, print it to standard output, and return nil.",
    "origin": "core",
    "examples": [
      "(printf \"Hello, %s\" \"Clove\") ; => nil",
      "(printf \"%d + %d = %d\\n\" 2 3 5) ; => nil"
    ]
  },
  {
    "name": "println",
    "signature": "println & values",
    "doc": "Print each value using display formatting, then emit a newline.",
    "origin": "core",
    "examples": [
      "(comment (println \"hello\" 42)) ; => nil ; Print with a trailing newline"
    ]
  },
  {
    "name": "puts",
    "signature": "puts & values",
    "doc": "Alias of println; print each value using display formatting and append a newline.",
    "origin": "core",
    "examples": [
      "(comment (puts \"hello\" 42)) ; => nil ; Print with a trailing newline"
    ]
  },
  {
    "name": "prn",
    "signature": "prn & values",
    "doc": "Print values with pr-str formatting and append a newline.",
    "origin": "core",
    "examples": [
      "(comment (prn {:a 1 :b 2})) ; => nil ; Print with pr-str formatting and newline"
    ]
  },
  {
    "name": "process::run",
    "signature": "process::run cmd [opts]",
    "doc": "Run an external command and capture stdout/stderr. opts: {:cwd :env {:KEY \"value\"} :clear-env bool :in stdin :out-enc :bytes :err-enc :bytes}.",
    "origin": "process",
    "examples": [
      "(get (process::run [\"echo\" \"hi\"]) :out) ; => \"hi\n\"",
      "(get (process::run [\"true\"]) :exit) ; => 0"
    ]
  },
  {
    "name": "process::sh",
    "signature": "process::sh cmd & args+opts",
    "doc": "Run an external command (strings followed by optional opts map {:dir :env {:KEY \"value\"} :stdin :stream?}). Returns {:exit code :out stdout :err stderr}.",
    "origin": "process",
    "examples": [
      "(get (process::sh \"echo\" \"hi\") :out) ; => \"hi\n\"",
      "(get (process::sh \"true\") :exit) ; => 0"
    ]
  },
  {
    "name": "process::sh-line",
    "signature": "process::sh-line line [opts]",
    "doc": "Run an external command from a single command-line string (shell-words split; no shell pipes or redirects).",
    "origin": "process",
    "examples": [
      "(get (process::sh-line \"echo hi\") :out) ; => \"hi\n\"",
      "(get (process::sh-line \"true\") :exit) ; => 0"
    ]
  },
  {
    "name": "process::sh!",
    "signature": "process::sh! cmd & args+opts",
    "doc": "Like process::sh but raises when the exit code is non-zero.",
    "origin": "process",
    "examples": [
      "(try (process::sh! \"false\") (catch RuntimeError _ :failed)) ; => :failed",
      "(get (process::sh! \"echo\" \"ok\") :err) ; => \"\""
    ]
  },
  {
    "name": "process::which",
    "signature": "process::which name",
    "doc": "Return the full path to the command found in PATH, or nil when not found.",
    "origin": "process",
    "examples": [
      "(comment (process::which \"git\")) ; => nil ; returns path when found"
    ]
  },
  {
    "name": "promise",
    "signature": "promise",
    "doc": "Create a pending promise that can be delivered once and dereferenced later.",
    "origin": "core",
    "examples": [
      "(promise) ; => #<promise state=pending>",
      "(let [p (promise)] (promise-deliver! p 42) (promise-deref p)) ; => 42"
    ]
  },
  {
    "name": "promise-all",
    "signature": "promise-all coll",
    "doc": "Return a promise that waits for every promise/future/task in coll and yields a vector of their values.",
    "origin": "core",
    "examples": [
      "(promise-deref (promise-all [(future (fn [] 1)) (future (fn [] 2))])) ; => [1 2]",
      "(promise-deref (promise-all [])) ; => []"
    ]
  },
  {
    "name": "promise-all-settled",
    "signature": "promise-all-settled coll",
    "doc": "Return a promise that resolves to vectors of {:status :fulfilled/:rejected, ...} for each input promise/future/task.",
    "origin": "core",
    "examples": [
      "(promise-deref (promise-all-settled [(future (fn [] :ok))])) ; => [{:status :fulfilled :value :ok}]",
      "(promise-deref (promise-all-settled [(future (fn [] (throw (runtime-error \"boom\"))))])) ; => [{:status :rejected :error \"Runtime error: boom\"}]"
    ]
  },
  {
    "name": "promise-any",
    "signature": "promise-any coll",
    "doc": "Return a promise that resolves with the first fulfilled value among the inputs (propagating an error if all reject).",
    "origin": "core",
    "examples": [
      "(promise-deref (promise-any [(future (fn [] :ok))])) ; => :ok",
      "(promise-deref (promise-any [(future (fn [] (throw (runtime-error \"fail\")))) (future (fn [] 1))])) ; => 1"
    ]
  },
  {
    "name": "promise-catch",
    "signature": "promise-catch source handler",
    "doc": "Return a promise that uses handler to supply a value when source rejects.",
    "origin": "core",
    "examples": [
      "(let [f (future (fn [] (throw (runtime-error \"boom\"))))] (promise-deref (promise-catch f (fn [_] :recovered)))) ; => :recovered",
      "(let [p (promise) handled (promise-catch p (fn [_] :handled))] (promise-deliver! p 1) (promise-deref handled)) ; => 1"
    ]
  },
  {
    "name": "promise-deliver!",
    "signature": "promise-deliver! promise value",
    "doc": "Resolve the promise with value. Returns true if the promise was delivered by this call.",
    "origin": "core",
    "examples": [
      "(let [p (promise)] (promise-deliver! p 42) (promise-deref p)) ; => 42",
      "(let [p (promise)] [(promise-deliver! p :ok) (promise-deliver! p :again)]) ; => [true false]"
    ]
  },
  {
    "name": "promise-deref",
    "signature": "promise-deref promise",
    "doc": "Block until the promise settles and return its value (or throw on error).",
    "origin": "core",
    "examples": [
      "(let [p (promise)] (promise-deliver! p 42) (promise-deref p)) ; => 42",
      "(promise-deref (promise-all [])) ; => []"
    ]
  },
  {
    "name": "promise-done?",
    "signature": "promise-done? promise|task|future",
    "doc": "True once the promise/task/future has been delivered, failed, or cancelled.",
    "origin": "core",
    "examples": [
      "(let [p (promise)] (promise-done? p)) ; => false",
      "(let [p (promise)] (promise-deliver! p :ok) (promise-done? p)) ; => true",
      "(let [f (future (fn [] 1))] (future-deref f) (promise-done? f)) ; => true"
    ]
  },
  {
    "name": "promise-error",
    "signature": "promise-error promise|task|future",
    "doc": "Return the error message when the promise/task/future completed with an exception, otherwise nil.",
    "origin": "core",
    "examples": [
      "(let [p (promise)] (promise-error p)) ; => nil",
      "(let [base (promise) failing (promise-then base (fn [_] (throw (runtime-error \"boom\"))))] (promise-deliver! base :start) (promise-error failing)) ; => \"Runtime error: boom\"",
      "(promise-error (future (fn [] (throw \"fail\")))) ; => \"Runtime error: fail\""
    ]
  },
  {
    "name": "promise-finally",
    "signature": "promise-finally source f",
    "doc": "Run f (with no args) after the promise/future/task settles and pass through the original value or error.",
    "origin": "core",
    "examples": [
      "(let [p (promise) final (promise-finally p (fn [] :cleanup))] (promise-deliver! p :ok) (promise-deref final)) ; => :ok",
      "(let [flag (atom false) final (promise-finally (future (fn [] 1)) (fn [] (atom-set! flag true)))] (promise-deref final) (atom-deref flag)) ; => true"
    ]
  },
  {
    "name": "promise-race",
    "signature": "promise-race coll",
    "doc": "Return a promise that resolves or rejects with the first settled promise/future/task in coll.",
    "origin": "core",
    "examples": [
      "(promise-deref (promise-race [(future (fn [] :x)) (future (fn [] :y))])) ; => :x",
      "(promise-deref (promise-race [(future (fn [] 1))])) ; => 1"
    ]
  },
  {
    "name": "promise-then",
    "signature": "promise-then source f",
    "doc": "Return a promise that applies f to the resolved value of the given promise/future/task.",
    "origin": "core",
    "examples": [
      "(let [p (promise) chain (promise-then p inc)] (promise-deliver! p 1) (promise-deref chain)) ; => 2",
      "(promise-deref (promise-then (future (fn [] 1)) (fn [x] (* x 10)))) ; => 10"
    ]
  },
  {
    "name": "promise?",
    "signature": "promise? value",
    "doc": "Predicate that returns true for promise handles.",
    "origin": "core",
    "examples": [
      "(promise? (promise)) ; => true",
      "(promise? :value) ; => false"
    ]
  },
  {
    "name": "quot",
    "signature": "quot dividend divisor",
    "doc": "Integer division that truncates toward zero (errors on division by zero).",
    "origin": "core",
    "examples": [
      "(quot 10 3) ; => 3",
      "(quot -7 3) ; => -2"
    ]
  },
  {
    "name": "quote",
    "signature": "quote form",
    "doc": "Prevent evaluation.",
    "origin": "special form",
    "examples": [
      "(quote [1 2]) ; => [1 2]"
    ]
  },
  {
    "name": "rand",
    "signature": "rand [upper]",
    "doc": "Return a random float in [0,1) or [0, upper) when a bound is supplied.",
    "origin": "core",
    "examples": [
      "(< (rand) 1.0) ; => true",
      "(< (rand 5.0) 5.0) ; => true"
    ]
  },
  {
    "name": "range",
    "signature": "range end",
    "doc": "Generate numbers from start (default 0) to end (exclusive) by step; 0-arity is an infinite lazy seq.",
    "origin": "core",
    "examples": [
      "(range 2 8 3) ; => [2 5]",
      "(vec (take 4 (range))) ; => [0 1 2 3]"
    ]
  },
  {
    "name": "re-find",
    "signature": "re-find pattern text",
    "doc": "Return the first regex match in text; with capture groups, returns a vector of the full match and captures.",
    "origin": "core",
    "examples": [
      "(re-find /\\d+/ \"foo123bar\") ; => \"123\"",
      "(re-find /(\\w+)-(\\d+)/ \"tag-42 end\") ; => [\"tag-42\" \"tag\" \"42\"]"
    ]
  },
  {
    "name": "re-matcher",
    "signature": "re-matcher pattern [text]",
    "doc": "Compile a regex from the pattern (string or regex); the optional text argument exists for compatibility and is ignored.",
    "origin": "string",
    "examples": [
      "(re-matcher \"foo\") ; => /foo/",
      "(re-matcher (re-pattern \"cl\") \"clove\") ; => /cl/"
    ]
  },
  {
    "name": "re-matches",
    "signature": "re-matches pattern text",
    "doc": "Return the match if regex matches the entire text, else nil; includes capture groups. Regex values are callable: (/.../ text) is equivalent and can be passed as a function (e.g. map/filter).",
    "origin": "core",
    "examples": [
      "(re-matches /\\d+/ \"123\") ; => \"123\"",
      "(re-matches /(\\w+)-(\\d+)/ \"tag-42\") ; => [\"tag-42\" \"tag\" \"42\"]",
      "(map /\\d+/ [\"1\" \"a2\" \"333\"]) ; => [\"1\" nil \"333\"]"
    ]
  },
  {
    "name": "re-pattern",
    "signature": "re-pattern s",
    "doc": "Compile a string into a regex value.",
    "origin": "string",
    "examples": [
      "(re-pattern \"a+\") ; => /a+/",
      "(re-pattern \"clove\") ; => /clove/"
    ]
  },
  {
    "name": "re-seq",
    "signature": "re-seq pattern text",
    "doc": "Return a lazy seq of successive regex matches in text.",
    "origin": "core",
    "examples": [
      "(re-seq /\\d+/ \"v1v22\") ; => (\"1\" \"22\")",
      "(re-seq /(\\w+)-(\\d+)/ \"a-1 b-22\") ; => ([\"a-1\" \"a\" \"1\"] [\"b-22\" \"b\" \"22\"])"
    ]
  },
  {
    "name": "realized?",
    "signature": "realized? value",
    "doc": "Return true when the delay has been realized.",
    "origin": "core",
    "examples": [
      "(let [d (delay 1)] [(realized? d) (deref d) (realized? d)]) ; => [false 1 true]",
      "(realized? 1) ; => false"
    ]
  },
  {
    "name": "read",
    "signature": "read [text]",
    "doc": "Read the first form from the given string (or from *in* when omitted) and return it as a value.",
    "origin": "core",
    "examples": [
      "(read \"[1 2 3]\") ; => [1 2 3]",
      "(read \"(+ 1 2)\") ; => (+ 1 2)"
    ]
  },
  {
    "name": "read-string",
    "signature": "read-string [text]",
    "doc": "Parse the first Clove/EDN form found in text and return the unevaluated value.",
    "origin": "core",
    "examples": [
      "(read-string \"[1 2 3]\") ; => [1 2 3]",
      "(read-string \"(+ 1 2)\") ; => (+ 1 2)"
    ]
  },
  {
    "name": "recur",
    "signature": "recur args",
    "doc": "Tail-call to the nearest loop/defn with new arguments.",
    "origin": "special form",
    "examples": [
      "(loop [n 0] (if (< n 2) (recur (inc n)) n)) ; => 2"
    ]
  },
  {
    "name": "reduce",
    "signature": "reduce f coll",
    "doc": "Combine a collection with f: without init uses the first element or calls f with no args on empty input; with init starts from that value.",
    "origin": "core",
    "examples": [
      "(reduce + [1 2 3 4]) ; => 10",
      "(reduce conj #{} [:x :y :x]) ; => #{:x :y}"
    ]
  },
  {
    "name": "refer",
    "signature": "refer ns & opts",
    "doc": "Refer public vars from ns into the current namespace.",
    "origin": "special form",
    "examples": [
      "(comment (refer app::core :refer [foo bar])) ; => nil ; Refer public vars into the current namespace"
    ]
  },
  {
    "name": "regex",
    "signature": "regex pattern-string",
    "doc": "Compile the string into a regex value.",
    "origin": "string",
    "examples": [
      "(regex \"[0-9]+\") ; => /[0-9]+/",
      "(re-find (regex \"cl.*\") \"clove\") ; => \"clove\""
    ]
  },
  {
    "name": "rem",
    "signature": "rem dividend divisor",
    "doc": "Integer remainder following quot semantics (x - (quot x y) * y).",
    "origin": "core",
    "examples": [
      "(rem 10 3) ; => 1",
      "(rem -7 3) ; => -1"
    ]
  },
  {
    "name": "remove",
    "signature": "remove pred coll",
    "doc": "Return the items of coll for which pred returns falsey (lazy when coll is a seq). Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(remove odd? [1 2 3 4]) ; => [2 4]",
      "(vec (remove #(= :skip %) [:run :skip :go])) ; => [:run :go]",
      "(vec (remove [x [1 2 3 4]] (odd? x))) ; => [2 4]"
    ]
  },
  {
    "name": "repeat",
    "signature": null,
    "doc": null,
    "origin": null,
    "examples": [
      "(take 3 (repeat :x)) ; => [:x :x :x]",
      "(repeat 4 7) ; => [7 7 7 7]"
    ]
  },
  {
    "name": "repeatedly",
    "signature": "repeatedly f\nrepeatedly n f",
    "doc": "Call f repeatedly, returning a lazy seq (infinite) or vector of n results.",
    "origin": "core",
    "examples": [
      "(take 3 (repeatedly (fn [] :tick))) ; => [:tick :tick :tick]",
      "(repeatedly 3 (fn [] :x)) ; => [:x :x :x]"
    ]
  },
  {
    "name": "repl",
    "signature": "repl\nrepl x",
    "doc": "Start an interactive REPL session. Also available as a function value. When called as (repl x), binds ?, ?v, *?, and *1 to x and returns x after the REPL ends.",
    "origin": "special form",
    "examples": [
      "(comment (repl)) ; => nil ; Start an interactive REPL session",
      "(comment (repl [1 2 3])) ; => [1 2 3] ; ? / ?v / *? / *1 refer to the initial value"
    ]
  },
  {
    "name": "?v",
    "signature": "?v",
    "doc": "Subject value when entering a debug REPL or calling (repl x); alias of ?.",
    "origin": "repl",
    "examples": []
  },
  {
    "name": "?f",
    "signature": "?f",
    "doc": "Function being invoked when the debug REPL was entered (repl-on-error).",
    "origin": "repl",
    "examples": []
  },
  {
    "name": "?args",
    "signature": "?args",
    "doc": "Arguments vector for the call that triggered the debug REPL.",
    "origin": "repl",
    "examples": []
  },
  {
    "name": "?call",
    "signature": "?call",
    "doc": "Call-site info map for the debug REPL (file/span/form).",
    "origin": "repl",
    "examples": []
  },
  {
    "name": "?e",
    "signature": "?e",
    "doc": "Error string captured when entering the debug REPL.",
    "origin": "repl",
    "examples": []
  },
  {
    "name": "replace",
    "signature": "replace smap coll",
    "doc": "Replace items in coll according to the substitution map smap.",
    "origin": "core",
    "examples": [
      "(replace {1 :one} [1 2 1]) ; => [:one 2 :one]",
      "(replace {:a :b} {:a 1 :c 2}) ; => {:b 1 :c 2}"
    ]
  },
  {
    "name": "replace-first",
    "signature": "replace-first [s match replacement]",
    "doc": "Replace only the first occurrence of a string or regex match with replacement.",
    "origin": "string",
    "examples": [
      "(replace-first \"taco cat cat\" \"cat\" \"dog\") ; => \"taco dog cat\"",
      "(replace-first \"foo-123-456\" /\\d+/ \"***\") ; => \"foo-***-456\""
    ]
  },
  {
    "name": "require",
    "signature": "require [lib & opts]",
    "doc": "Load a namespace or file module. String targets load files, accept the same options, and assign an implicit namespace when the file has no (ns ...) form.",
    "origin": "special form",
    "examples": [
      "(comment (require app::core :as core)) ; => nil ; Load app::core and alias as core",
      "(comment (require app::string :refer [trim join])) ; => nil ; Refer selected symbols",
      "(comment (require app::math :as m :refer [add sub])) ; => nil ; Use alias and refer together",
      "(comment (require \"examples/hello\" :as hello)) ; => nil ; Load a file module by path"
    ]
  },
  {
    "name": "require-native",
    "signature": "require-native name",
    "doc": "Load a native plugin by name. Native plugins are disabled by default; enable with --allow-native-plugins and optionally --plugin-dir.",
    "origin": "core",
    "examples": []
  },
  {
    "name": "use",
    "signature": "use feature bool | use default-interop/foreign lang",
    "doc": "Alias of use-syntax; enable or disable a syntax/runtime feature (e.g. dot-chain, foreign-blocks). Also accepts (use default-interop/foreign <lang>) to set the default foreign language for the current file (extension wins with a warning).",
    "origin": "special form",
    "examples": [
      "(use dot-chain true) ; => true",
      "(use default-interop :py) ; file default for ${...}/$Foo.bar"
    ]
  },
  {
    "name": "use-syntax",
    "signature": "use-syntax feature bool",
    "doc": "Enable or disable a syntax/runtime feature (e.g. dot-chain, foreign-blocks, repl-on-error). Returns the applied boolean.",
    "origin": "special form",
    "examples": [
      "(use-syntax dot-chain true) ; => true",
      "(use-syntax repl-on-error true) ; => true"
    ]
  },
  {
    "name": "reset!",
    "signature": "reset! atom value",
    "doc": "Alias of atom-set!; replace the atom value with value.",
    "origin": "core",
    "examples": [
      "(let [c (atom 0)] (reset! c 42)) ; => 42",
      "(let [f (atom true)] (reset! f false) (deref f)) ; => false"
    ]
  },
  {
    "name": "resolve",
    "signature": "resolve sym",
    "doc": "Resolve a symbol to its value in the current namespace.",
    "origin": "special form",
    "examples": [
      "(comment (resolve 'app::core::foo)) ; => nil ; Resolve a symbol in the current namespace"
    ]
  },
  {
    "name": "rest",
    "signature": "rest coll",
    "doc": "Return a sequence of items after the first; empty seq if coll is empty or nil.",
    "origin": "core",
    "examples": [
      "(rest [1 2 3]) ; => [2 3]"
    ]
  },
  {
    "name": "reverse",
    "signature": "reverse coll",
    "doc": "Return the collection's items in reverse order (lists/vectors retain structure, sets/seqs realize into vectors).",
    "origin": "core",
    "examples": [
      "(reverse [1 2 3]) ; => [3 2 1]",
      "(reverse (list :a :b)) ; => (:b :a)"
    ]
  },
  {
    "name": "reverse-str",
    "signature": "reverse-str s",
    "doc": "Reverse the characters of the string.",
    "origin": "string",
    "examples": [
      "(reverse-str \"clove\") ; => \"evolc\"",
      "(reverse-str \"\ud83d\ude00\ud83d\udc4d\") ; => \"\ud83d\udc4d\ud83d\ude00\""
    ]
  },
  {
    "name": "rseq",
    "signature": "rseq coll",
    "doc": "Return a seq of the collection's items in reverse order (vectors, lists, strings, sorted maps/sets, or nil).",
    "origin": "core",
    "examples": [
      "(vec (rseq [1 2 3])) ; => [3 2 1]",
      "(vec (rseq (sorted-set 1 2 3))) ; => [3 2 1]"
    ]
  },
  {
    "name": "runtime-error",
    "signature": "runtime-error & parts",
    "doc": "Concatenate parts into a string and raise a runtime error.",
    "origin": "core",
    "examples": [
      "(try (runtime-error \"boom\") (catch RuntimeError e :failed)) ; => :failed",
      "(try (runtime-error \"bad\" 42) (catch RuntimeError e e)) ; => \"bad 42\""
    ]
  },
  {
    "name": "second",
    "signature": "second coll",
    "doc": "Return the second element of coll (or nil when absent).",
    "origin": "core",
    "examples": [
      "(second [10 20 30]) ; => 20",
      "(second []) ; => nil"
    ]
  },
  {
    "name": "select",
    "signature": "select cases [opts]",
    "doc": "Race channel operations. cases is a vector of channels to take from or [:put chan value] forms. opts may contain {:timeout duration :default value}. Returns [value chan] for takes, [true chan] for puts, or [default nil] when no cases are immediately ready (with :default making the call non-blocking).",
    "origin": "core",
    "examples": [
      "(let [c (chan 1)] (chan-put! c 42) (select [c])) ; => [42 #<chan id=1 cap=1 len=0 closed=false>]",
      "(let [c (chan 1)] (select [[:put c :ok]])) ; => [true #<chan id=1 cap=1 len=1 closed=false>]",
      "(let [c (chan 1)] (chan-put! c :ready) (select [c] {:default :idle})) ; => [:ready #<chan id=1 cap=1 len=0 closed=false>]"
    ]
  },
  {
    "name": "select-keys",
    "signature": "select-keys m keys",
    "doc": "Return a map containing only the entries whose keys appear in keys.",
    "origin": "core",
    "examples": [
      "(select-keys {:a 1 :b 2 :c 3} [:a :c]) ; => {:a 1 :c 3}",
      "(select-keys {:x 1} [:missing :x]) ; => {:x 1}"
    ]
  },
  {
    "name": "if",
    "signature": "if test then else?",
    "doc": "Conditional branching; evaluate then when test is truthy, else otherwise.",
    "origin": "special form",
    "examples": [
      "(if true :ok :ng) ; => :ok",
      "(if false :ok :ng) ; => :ng"
    ]
  },
  {
    "name": "seq",
    "signature": "seq coll",
    "doc": "Return a sequence view of coll, or nil when coll is empty/nil.",
    "origin": "core",
    "examples": [
      "(seq [1 2]) ; => (1 2)"
    ]
  },
  {
    "name": "seq?",
    "signature": "seq? value",
    "doc": "True when the value is a seq handle (produced by seq/rseq/etc.).",
    "origin": "core",
    "examples": [
      "(seq? (seq [1 2])) ; => true",
      "(seq? [1 2]) ; => false"
    ]
  },
  {
    "name": "sequential?",
    "signature": "sequential? x",
    "doc": "True for list/vector/seq values.",
    "origin": "core",
    "examples": [
      "(sequential? [1 2]) ; => true"
    ]
  },
  {
    "name": "set",
    "signature": "set & values",
    "doc": "Create a set from the supplied values (duplicates are ignored).",
    "origin": "core",
    "examples": [
      "(set 1 2 1) ; => #{1 2}",
      "(set) ; => #{}"
    ]
  },
  {
    "name": "set!",
    "signature": "set! var value",
    "doc": "Mutate an existing var or dynamic var binding.",
    "origin": "special form",
    "examples": [
      "(do (def x 1) (set! x 2) x) ; => 2"
    ]
  },
  {
    "name": "set?",
    "signature": "set? x",
    "doc": "True when the value is a set.",
    "origin": "core",
    "examples": [
      "(set? #{1 2}) ; => true"
    ]
  },
  {
    "name": "shell::escape",
    "signature": "shell::escape args",
    "doc": "Return a shell-escaped string joining the vector/list of arguments.",
    "origin": "shell",
    "examples": [
      "(shell::escape [\"echo\" \"a b\"]) ; => \"echo 'a b'\"",
      "(shell::escape [\"ls\" \"C:/Program Files\"]) ; => \"ls 'C:/Program Files'\""
    ]
  },
  {
    "name": "shell::split",
    "signature": "shell::split text",
    "doc": "Split text using POSIX shell quoting rules, returning a vector of arguments.",
    "origin": "shell",
    "examples": [
      "(shell::split \"foo bar\") ; => [\"foo\" \"bar\"]",
      "(shell::split \"cmd \\\"spaced arg\\\"\") ; => [\"cmd\" \"spaced arg\"]"
    ]
  },
  {
    "name": "io::slurp-bytes",
    "signature": "io::slurp-bytes path",
    "doc": "Read the file or URL at path into a vector of bytes.",
    "origin": "io",
    "examples": [
      "(do (io::spit-bytes \"tmp/doc-io-slurp.bin\" [65 66]) (let [bytes (io::slurp-bytes \"tmp/doc-io-slurp.bin\")] (fs::delete \"tmp/doc-io-slurp.bin\") bytes)) ; => [65 66]"
    ]
  },
  {
    "name": "io::spit-bytes",
    "signature": "io::spit-bytes path bytes",
    "doc": "Write the byte vector/list to the file at path. Returns path.",
    "origin": "io",
    "examples": [
      "(let [path (io::spit-bytes \"tmp/doc-io-spit.bin\" [1 2 3])] (let [bytes (io::slurp-bytes path)] (fs::delete path) bytes)) ; => [1 2 3]"
    ]
  },
  {
    "name": "fs::file-exists?",
    "signature": "fs::file-exists? path",
    "doc": "Return true if the path exists.",
    "origin": "fs",
    "examples": [
      "(let [path \"tmp/doc-fs-exists.bin\"] (io::spit-bytes path [0]) (let [ok (fs::file-exists? path)] (fs::delete path) ok)) ; => true"
    ]
  },
  {
    "name": "fs::file?",
    "signature": "fs::file? path",
    "doc": "Return true if the path exists and is a regular file.",
    "origin": "fs",
    "examples": [
      "(let [path \"tmp/doc-fs-file.bin\"] (io::spit-bytes path [7]) (let [ok (fs::file? path)] (fs::delete path) ok)) ; => true"
    ]
  },
  {
    "name": "fs::dir?",
    "signature": "fs::dir? path",
    "doc": "Return true if the path exists and is a directory.",
    "origin": "fs",
    "examples": [
      "(let [path \"tmp/doc-fs-dir\"] (fs::mkdirs path) (let [ok (fs::dir? path)] (fs::delete path) ok)) ; => true"
    ]
  },
  {
    "name": "fs::list-dir",
    "signature": "fs::list-dir path",
    "doc": "Return a vector of entry names in the directory at path.",
    "origin": "fs",
    "examples": [
      "(let [dir \"tmp/doc-fs-list-dir\"] (fs::mkdirs dir) (io::spit-bytes \"tmp/doc-fs-list-dir/one.txt\" [1]) (let [items (fs::list-dir dir)] (fs::delete dir) items)) ; => [\"one.txt\"]"
    ]
  },
  {
    "name": "fs::mkdir",
    "signature": "fs::mkdir path",
    "doc": "Create the directory at path (non-recursive). Returns path.",
    "origin": "fs",
    "examples": [
      "(let [path (do (fs::delete \"tmp/doc-fs-mkdir\") (fs::mkdir \"tmp/doc-fs-mkdir\"))] (fs::delete path) path) ; => \"tmp/doc-fs-mkdir\""
    ]
  },
  {
    "name": "fs::mkdirs",
    "signature": "fs::mkdirs path",
    "doc": "Create the directory path and parents. Returns path.",
    "origin": "fs",
    "examples": [
      "(let [path (do (fs::delete \"tmp/doc-fs-mkdirs\") (fs::mkdirs \"tmp/doc-fs-mkdirs/nested\"))] (fs::delete \"tmp/doc-fs-mkdirs\") path) ; => \"tmp/doc-fs-mkdirs/nested\""
    ]
  },
  {
    "name": "fs::delete",
    "signature": "fs::delete path",
    "doc": "Delete the file or directory at path (directories removed recursively). Returns path.",
    "origin": "fs",
    "examples": [
      "(do (io::spit-bytes \"tmp/doc-fs-delete.bin\" [1]) (fs::delete \"tmp/doc-fs-delete.bin\")) ; => \"tmp/doc-fs-delete.bin\""
    ]
  },
  {
    "name": "fs::copy",
    "signature": "fs::copy from to",
    "doc": "Copy the file from from to to. Returns destination path.",
    "origin": "fs",
    "examples": [
      "(let [src \"tmp/doc-fs-copy-src.bin\" dst \"tmp/doc-fs-copy-dst.bin\"] (io::spit-bytes src [9]) (let [out (fs::copy src dst)] (fs::delete src) (fs::delete dst) out)) ; => \"tmp/doc-fs-copy-dst.bin\""
    ]
  },
  {
    "name": "fs::move",
    "signature": "fs::move from to",
    "doc": "Move or rename the file from from to to. Returns destination path.",
    "origin": "fs",
    "examples": [
      "(let [src \"tmp/doc-fs-move-src.bin\" dst \"tmp/doc-fs-move-dst.bin\"] (io::spit-bytes src [9]) (let [out (fs::move src dst)] (fs::delete dst) out)) ; => \"tmp/doc-fs-move-dst.bin\""
    ]
  },
  {
    "name": "fs::glob",
    "signature": "fs::glob pattern & [opts]",
    "doc": "Return a vector of paths matching pattern. opts: {:cwd PATH :recursive? bool :dotfiles? bool :sorted? bool :only :file|:dir|:any :follow-symlinks? bool :on-error :skip|:throw}. :on-error defaults to :skip.",
    "origin": "fs",
    "examples": [
      "(let [dir \"tmp/doc-fs-glob\"] (fs::mkdirs dir) (io::spit-bytes \"tmp/doc-fs-glob/a.txt\" [1]) (io::spit-bytes \"tmp/doc-fs-glob/b.txt\" [2]) (let [items (fs::glob \"tmp/doc-fs-glob/*.txt\")] (fs::delete dir) items)) ; => [\"tmp/doc-fs-glob/a.txt\" \"tmp/doc-fs-glob/b.txt\"]"
    ]
  },
  {
    "name": "fs::glob*",
    "signature": "fs::glob* pattern & [opts]",
    "doc": "Return a lazy seq of paths matching pattern. opts: {:cwd PATH :recursive? bool :dotfiles? bool :sorted? bool :only :file|:dir|:any :follow-symlinks? bool :on-error :skip|:throw}. :on-error defaults to :skip.",
    "origin": "fs",
    "examples": [
      "(let [dir \"tmp/doc-fs-glob-star\"] (fs::mkdirs dir) (io::spit-bytes \"tmp/doc-fs-glob-star/x.clv\" [1]) (io::spit-bytes \"tmp/doc-fs-glob-star/y.clv\" [2]) (let [items (into [] (fs::glob* \"tmp/doc-fs-glob-star/*.clv\" {:sorted? true}))] (fs::delete dir) items)) ; => [\"tmp/doc-fs-glob-star/x.clv\" \"tmp/doc-fs-glob-star/y.clv\"]"
    ]
  },
  {
    "name": "io::line-seq",
    "signature": "io::line-seq path",
    "doc": "Return a lazy seq of lines from the file at path.",
    "origin": "io",
    "examples": [
      "(do (io::spit-bytes \"tmp/doc-io-lines.txt\" [97 10 98 10]) (let [items (into [] (io::line-seq \"tmp/doc-io-lines.txt\"))] (fs::delete \"tmp/doc-io-lines.txt\") items)) ; => [\"a\" \"b\"]"
    ]
  },
  {
    "name": "io::read-line",
    "signature": "io::read-line",
    "doc": "Read a line from stdin, stripping the trailing newline.",
    "origin": "io",
    "examples": [
      "(comment (io::read-line)) ; => nil ; Read a line from stdin"
    ]
  },
  {
    "name": "io::read-all",
    "signature": "io::read-all",
    "doc": "Read all remaining stdin input into a string.",
    "origin": "io",
    "examples": [
      "(comment (io::read-all)) ; => nil ; Read all remaining stdin into a string"
    ]
  },
  {
    "name": "io::resource-url",
    "signature": "io::resource-url name",
    "doc": "Resolve resource name to a resource:// or file:// URL string, or nil when not found.",
    "origin": "io",
    "examples": [
      "(comment (io::resource-url \"assets/bg.png\")) ; => nil ; returns URL when found"
    ]
  },
  {
    "name": "io::resource-bytes",
    "signature": "io::resource-bytes name",
    "doc": "Read resource bytes by name. Returns nil when missing.",
    "origin": "io",
    "examples": [
      "(comment (io::resource-bytes \"assets/bg.png\")) ; => nil ; returns byte vector"
    ]
  },
  {
    "name": "io::resource->tempfile",
    "signature": "io::resource->tempfile name",
    "doc": "Resolve a resource name to a file path, writing embedded bytes to a temp file when needed.",
    "origin": "io",
    "examples": [
      "(comment (io::resource->tempfile \"assets/bg.png\")) ; => nil ; returns file path"
    ]
  },
  {
    "name": "slurp",
    "signature": "slurp path",
    "doc": "Read the entire file at path into a string.",
    "origin": "core",
    "examples": [
      "(comment (slurp \"path/to/file.txt\")) ; => nil ; Read entire file into a string"
    ]
  },
  {
    "name": "some",
    "signature": "some pred coll",
    "doc": "Return the first truthy value of (pred item) across coll, or nil. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(some #{:b} [:a :b :c]) ; => :b",
      "(some (fn [x] (when (even? x) (* x 10))) [1 3 4 5]) ; => 40",
      "(some [x [1 3 4 5]] (if (even? x) (* x 10) nil)) ; => 40"
    ]
  },
  {
    "name": "some->",
    "signature": "some-> expr & forms",
    "doc": "Thread expr while it stays non-nil, inserting as first arg.",
    "origin": "special form",
    "examples": [
      "(some-> {:a 1} (get :a) inc) ; => 2"
    ]
  },
  {
    "name": "some->>",
    "signature": "some->> expr & forms",
    "doc": "Thread expr while it stays non-nil, inserting as last arg.",
    "origin": "special form",
    "examples": [
      "(some->> [1 2] (map inc) (first)) ; => 2"
    ]
  },
  {
    "name": "some-fn",
    "signature": "some-fn & preds",
    "doc": "Return a predicate that returns the first truthy result from preds applied to the same args.",
    "origin": "core",
    "examples": [
      "((some-fn number? string?) 10) ; => true",
      "((some-fn keyword? symbol?) :a) ; => true"
    ]
  },
  {
    "name": "some?",
    "signature": "some? x",
    "doc": "Returns true for any value except nil/false.",
    "origin": "core",
    "examples": [
      "(some? 0) ; => true"
    ]
  },
  {
    "name": "sort",
    "signature": "sort coll\nsort comparator coll",
    "doc": "Strict, stable sort of coll with optional comparator.",
    "origin": "core",
    "examples": [
      "(sort [3 1 2]) ; => [1 2 3]",
      "(sort #(compare %2 %1) [:c :a :b]) ; => [:c :b :a]"
    ]
  },
  {
    "name": "sort-by",
    "signature": "sort-by keyfn coll\nsort-by keyfn comparator coll",
    "doc": "Strict, stable sort by keyfn with optional comparator. Supports [pat coll] sugar for the 2-arity form.",
    "origin": "core",
    "examples": [
      "(sort-by count [\"aa\" \"b\" \"ccc\"]) ; => [\"b\" \"aa\" \"ccc\"]",
      "(sort-by first #(> %1 %2) [[1 :a] [3 :b] [2 :c]]) ; => [[3 :b] [2 :c] [1 :a]]",
      "(sort-by [s [\"aa\" \"b\" \"ccc\"]] (count s)) ; => [\"b\" \"aa\" \"ccc\"]"
    ]
  },
  {
    "name": "sorted-map",
    "signature": "sorted-map & kvs\nsorted-map coll-or-entries",
    "doc": "Create a sorted map ordered by core::compare; accepts key/value pairs or a collection of entries.",
    "origin": "core",
    "examples": [
      "(sorted-map :b 2 :a 1) ; => {:a 1 :b 2}",
      "(sorted-map {:b 2 :a 1}) ; => {:a 1 :b 2}"
    ]
  },
  {
    "name": "sorted-map-desc",
    "signature": "sorted-map-desc & kvs\nsorted-map-desc coll-or-entries",
    "doc": "Create a sorted map ordered by core::compare-desc; accepts key/value pairs or a collection of entries.",
    "origin": "core",
    "examples": [
      "(sorted-map-desc :b 2 :a 1) ; => {:b 2 :a 1}",
      "(sorted-map-desc {:b 2 :a 1}) ; => {:b 2 :a 1}"
    ]
  },
  {
    "name": "sorted-map-by",
    "signature": "sorted-map-by comparator & kvs\nsorted-map-by comparator coll-or-entries",
    "doc": "Create a sorted map ordered by comparator; accepts key/value pairs or a collection of entries.",
    "origin": "core",
    "examples": [
      "(sorted-map-by compare :b 2 :a 1) ; => {:a 1 :b 2}",
      "(sorted-map-by compare {:b 2 :a 1}) ; => {:a 1 :b 2}"
    ]
  },
  {
    "name": "sorted-set",
    "signature": "sorted-set & values\nsorted-set coll",
    "doc": "Create a sorted set ordered by core::compare; accepts values or a collection.",
    "origin": "core",
    "examples": [
      "(sorted-set 3 1 2) ; => #{1 2 3}",
      "(sorted-set [:b :c :a]) ; => #{:a :b :c}"
    ]
  },
  {
    "name": "sorted-set-desc",
    "signature": "sorted-set-desc & values\nsorted-set-desc coll",
    "doc": "Create a sorted set ordered by core::compare-desc; accepts values or a collection.",
    "origin": "core",
    "examples": [
      "(sorted-set-desc 3 1 2) ; => #{3 2 1}",
      "(sorted-set-desc [:b :c :a]) ; => #{:c :b :a}"
    ]
  },
  {
    "name": "sorted-set-by",
    "signature": "sorted-set-by comparator & values\nsorted-set-by comparator coll",
    "doc": "Create a sorted set ordered by comparator; accepts values or a collection.",
    "origin": "core",
    "examples": [
      "(sorted-set-by compare 3 1 2) ; => #{1 2 3}",
      "(sorted-set-by compare [:b :c :a]) ; => #{:a :b :c}"
    ]
  },
  {
    "name": "sorted?",
    "signature": "sorted? value",
    "doc": "True when value is a sorted map or sorted set.",
    "origin": "core",
    "examples": [
      "(sorted? (sorted-map-by compare :a 1)) ; => true",
      "(sorted? #{1 2}) ; => false"
    ]
  },
  {
    "name": "source",
    "signature": "source target",
    "doc": "Return the source string for the symbol or value (or nil).",
    "origin": "core",
    "examples": [
      "(defn f [x] (+ x 1)) (source 'f) ; => \"(defn f [x] (+ x 1))\""
    ]
  },
  {
    "name": "spawn",
    "signature": "spawn callable [opts]",
    "doc": "Run the zero-arity callable on another thread and return a task handle.",
    "origin": "core",
    "examples": [
      "(task? (spawn (fn [] 42))) ; => true",
      "(task-deref (spawn (fn [] 1))) ; => 1"
    ]
  },
  {
    "name": "spit",
    "signature": "spit path content",
    "doc": "Write content to the file at path. Returns path.",
    "origin": "core",
    "examples": [
      "(let [path (spit \"tmp/doc-spit.txt\" \"hello\")] (fs::delete path) path) ; => \"tmp/doc-spit.txt\""
    ]
  },
  {
    "name": "split-at",
    "signature": "split-at n coll",
    "doc": "Split coll at n and return [prefix rest]; seq inputs keep the rest as a lazy seq.",
    "origin": "core",
    "examples": [
      "(split-at 2 [1 2 3 4]) ; => [[1 2] [3 4]]",
      "(split-at 1 (range 4)) ; => [[0] (1 2 3)]"
    ]
  },
  {
    "name": "split-with",
    "signature": "split-with pred coll",
    "doc": "Split coll at the first item where pred is falsey; returns [prefix rest]. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(split-with neg? [-2 -1 0 1]) ; => [[-2 -1] [0 1]]",
      "(split-with even? [2 4 5 6]) ; => [[2 4] [5 6]]",
      "(split-with [x [-2 -1 0 1]] (neg? x)) ; => [[-2 -1] [0 1]]"
    ]
  },
  {
    "name": "split",
    "signature": "split [s pattern]\nsplit [s pattern limit]",
    "doc": "Split s around pattern (string or regex); optional limit bounds the number of pieces.",
    "origin": "string",
    "examples": [
      "(split \"a,b,c\" /,/) ; => [\"a\" \"b\" \"c\"]",
      "(split \"path\" // 2) ; => [\"\" \"path\"]"
    ]
  },
  {
    "name": "split-lines",
    "signature": "split-lines s",
    "doc": "Split the string on newline boundaries and return a vector of lines.",
    "origin": "string",
    "examples": [
      "(split-lines \"a\nb\") ; => [\"a\" \"b\"]",
      "(split-lines \"one\r\ntwo\") ; => [\"one\" \"two\"]"
    ]
  },
  {
    "name": "lines",
    "signature": "lines s",
    "doc": "Split the string into lines, keeping line endings.",
    "origin": "string",
    "examples": [
      "(lines \"a\\nb\\n\") ; => [\"a\\n\" \"b\\n\"]",
      "(lines \"a\\r\\nb\") ; => [\"a\\r\\n\" \"b\"]"
    ]
  },
  {
    "name": "starts-with?",
    "signature": "starts-with? [s prefix]",
    "doc": "True when the string begins with prefix.",
    "origin": "string",
    "examples": [
      "(starts-with? \"clove\" \"cl\") ; => true",
      "(starts-with? \"clove\" \"ve\") ; => false"
    ]
  },
  {
    "name": "std::prelude-version",
    "signature": "std::prelude-version",
    "doc": "Return the version string of the built-in std::prelude placeholder.",
    "origin": "core",
    "examples": [
      "(std::prelude-version) ; => \"clove-std-dev\""
    ]
  },
  {
    "name": "str",
    "signature": "str & values",
    "doc": "Concatenate the string form of each argument (nil renders as \"nil\").",
    "origin": "core",
    "examples": [
      "(str \"a\" 1) ; => \"a1\""
    ]
  },
  {
    "name": "str-replace",
    "signature": "str-replace [s match replacement]",
    "doc": "Replace every occurrence of match (string) in s with replacement.",
    "origin": "string",
    "examples": [
      "(str-replace \"taco cat\" \"cat\" \"dog\") ; => \"taco dog\"",
      "(str-replace \"000111\" \"0\" \"x\") ; => \"xxx111\""
    ]
  },
  {
    "name": "string::ends-with?",
    "signature": "ends-with? [s suffix]",
    "doc": "True when the string ends with suffix.",
    "origin": "string",
    "examples": [
      "(string::ends-with? \"clove\" \"ove\") ; => true"
    ]
  },
  {
    "name": "string::includes?",
    "signature": "includes? [s substr]",
    "doc": "True when the string contains the given substring.",
    "origin": "string",
    "examples": [
      "(string::includes? \"clove\" \"lov\") ; => true"
    ]
  },
  {
    "name": "string::lower-case",
    "signature": "lower-case [s]",
    "doc": "Return the lower-case form of the string.",
    "origin": "string",
    "examples": [
      "(string::lower-case \"Clove\") ; => \"clove\""
    ]
  },
  {
    "name": "string::replace",
    "signature": "replace [s match replacement]",
    "doc": "Replace every occurrence of match (string) in s with replacement.",
    "origin": "string",
    "examples": [
      "(string::replace \"taco cat\" \"cat\" \"dog\") ; => \"taco dog\"",
      "(string::replace \"000111\" \"0\" \"x\") ; => \"xxx111\""
    ]
  },
  {
    "name": "string::replace-first",
    "signature": "replace-first [s match replacement]",
    "doc": "Replace only the first occurrence of a string or regex match with replacement.",
    "origin": "string",
    "examples": [
      "(string::replace-first \"taco cat cat\" \"cat\" \"dog\") ; => \"taco dog cat\"",
      "(string::replace-first \"foo-123-456\" /\\d+/ \"***\") ; => \"foo-***-456\""
    ]
  },
  {
    "name": "string::split",
    "signature": "split [s pattern]\nsplit [s pattern limit]",
    "doc": "Split s around pattern (string or regex); optional limit bounds the number of pieces.",
    "origin": "string",
    "examples": [
      "(string::split \"a,b,c\" /,/) ; => [\"a\" \"b\" \"c\"]",
      "(string::split \"path\" // 2) ; => [\"\" \"path\"]"
    ]
  },
  {
    "name": "string::starts-with?",
    "signature": "starts-with? [s prefix]",
    "doc": "True when the string begins with prefix.",
    "origin": "string",
    "examples": [
      "(string::starts-with? \"clove\" \"cl\") ; => true"
    ]
  },
  {
    "name": "string::trim",
    "signature": "trim [s]",
    "doc": "Remove leading and trailing Unicode whitespace from the string.",
    "origin": "string",
    "examples": [
      "(string::trim \"  clove  \") ; => \"clove\"",
      "(string::trim \"\\nhello\\t\") ; => \"hello\""
    ]
  },
  {
    "name": "string::upper-case",
    "signature": "upper-case [s]",
    "doc": "Return the upper-case form of the string.",
    "origin": "string",
    "examples": [
      "(string::upper-case \"Clove\") ; => \"CLOVE\""
    ]
  },
  {
    "name": "path::cwd",
    "signature": "path::cwd",
    "doc": "Return the current working directory path used by the runtime.",
    "origin": "path",
    "examples": [
      "(comment (path::cwd)) ; => nil ; returns cwd path"
    ]
  },
  {
    "name": "path::home-dir",
    "signature": "path::home-dir",
    "doc": "Return the user's home directory path, or nil when unavailable.",
    "origin": "path",
    "examples": [
      "(comment (path::home-dir)) ; => nil ; returns home dir path"
    ]
  },
  {
    "name": "path::temp-dir",
    "signature": "path::temp-dir",
    "doc": "Return the system temporary directory path.",
    "origin": "path",
    "examples": [
      "(comment (path::temp-dir)) ; => nil ; returns temp dir path"
    ]
  },
  {
    "name": "path::join",
    "signature": "path::join & parts",
    "doc": "Join one or more path segments and normalize the result using the host separators.",
    "origin": "path",
    "examples": [
      "(path::join \"/tmp\" \"logs\" \"app.log\") ; => \"/tmp/logs/app.log\"",
      "(path::join \"src\" \"..\" \"lib\" \"core.clv\") ; => \"lib/core.clv\""
    ]
  },
  {
    "name": "path::basename",
    "signature": "path::basename path",
    "doc": "Return the final path segment (file name) or an empty string when there is no segment.",
    "origin": "path",
    "examples": [
      "(path::basename \"/tmp/archive.tar.gz\") ; => \"archive.tar.gz\"",
      "(path::basename \"src/main.clv\") ; => \"main.clv\""
    ]
  },
  {
    "name": "path::dirname",
    "signature": "path::dirname path",
    "doc": "Return the parent directory of the path (empty string when none).",
    "origin": "path",
    "examples": [
      "(path::dirname \"/tmp/archive.tar.gz\") ; => \"/tmp\"",
      "(path::dirname \"main.clv\") ; => \"\""
    ]
  },
  {
    "name": "path::extname",
    "signature": "path::extname path",
    "doc": "Return the file extension (including the leading dot) or an empty string when absent.",
    "origin": "path",
    "examples": [
      "(path::extname \"/tmp/archive.tar.gz\") ; => \".gz\"",
      "(path::extname \"README\") ; => \"\""
    ]
  },
  {
    "name": "path::normalize",
    "signature": "path::normalize path",
    "doc": "Collapse \".\"/\"..\" segments and duplicate separators to produce a clean path string.",
    "origin": "path",
    "examples": [
      "(path::normalize \"/tmp//foo/../bar\") ; => \"/tmp/bar\"",
      "(path::normalize \"./src/./core\") ; => \"src/core\""
    ]
  },
  {
    "name": "path::canonicalize",
    "signature": "path::canonicalize path",
    "doc": "Resolve a path to its canonical absolute form (filesystem lookup).",
    "origin": "path",
    "examples": [
      "(comment (path::canonicalize \".\")) ; => nil ; returns canonical path"
    ]
  },
  {
    "name": "path::absolute?",
    "signature": "path::absolute? path",
    "doc": "Return true when the given path is absolute on the current platform.",
    "origin": "path",
    "examples": [
      "(path::absolute? \"/tmp\") ; => true",
      "(path::absolute? \"src/main.clv\") ; => false"
    ]
  },
  {
    "name": "path::relative?",
    "signature": "path::relative? path",
    "doc": "Return true when the path is relative (not absolute).",
    "origin": "path",
    "examples": [
      "(path::relative? \"src/main.clv\") ; => true",
      "(path::relative? \"/tmp/log\") ; => false"
    ]
  },
  {
    "name": "path::resolve",
    "signature": "path::resolve path",
    "doc": "Resolve the path to an absolute, normalized location (relative paths use the current working directory).",
    "origin": "path",
    "examples": [
      "(path::resolve \"/tmp/../var/log/app.log\") ; => \"/var/log/app.log\"",
      "(path::resolve \"/etc/./clove/config.clv\") ; => \"/etc/clove/config.clv\""
    ]
  },
  {
    "name": "path::source-dir",
    "signature": "path::source-dir",
    "doc": "Return the directory of the current source file, or nil in REPL/virtual sources.",
    "origin": "path",
    "examples": [
      "(comment (path::source-dir)) ; => nil ; returns nil in REPL/virtual sources"
    ]
  },
  {
    "name": "path::sanitize",
    "signature": "path::sanitize s [opts]",
    "doc": "Return a safe filename segment. opts: {:replacement str :max-len int :lower? bool :windows? bool}.",
    "origin": "path",
    "examples": [
      "(path::sanitize \"a/b:c*?.txt\") ; => \"a_b_c__.txt\"",
      "(path::sanitize \"..\") ; => \"_\"",
      "(path::sanitize \"CON\") ; => \"_CON\""
    ]
  },
  {
    "name": "path::sanitize-filename",
    "signature": "path::sanitize-filename s [opts]",
    "doc": "Alias of path::sanitize.",
    "origin": "path",
    "examples": [
      "(path::sanitize-filename \"a/b:c*?.txt\") ; => \"a_b_c__.txt\"",
      "(path::sanitize-filename \"..\") ; => \"_\"",
      "(path::sanitize-filename \"CON\") ; => \"_CON\""
    ]
  },
  {
    "name": "path::sanitize-path",
    "signature": "path::sanitize-path s [opts]",
    "doc": "Return a safe relative path using '/' separators. opts are the same as path::sanitize.",
    "origin": "path",
    "examples": [
      "(path::sanitize-path \"a/../b\") ; => \"b\"",
      "(path::sanitize-path \"/etc/passwd\") ; => \"etc/passwd\""
    ]
  },
  {
    "name": "path::slugify",
    "signature": "path::slugify s [opts]",
    "doc": "Return a URL-friendly slug. opts: {:replacement str :max-len int :lower? bool :windows? bool}.",
    "origin": "path",
    "examples": [
      "(path::slugify \"Hello, World!\") ; => \"hello-world\"",
      "(path::slugify \"Hello, World!\" {:lower? false}) ; => \"Hello-World\""
    ]
  },
  {
    "name": "string?",
    "signature": "string? x",
    "doc": "True when the value is a string.",
    "origin": "core",
    "examples": [
      "(string? \"hi\") ; => true"
    ]
  },
  {
    "name": "walk::stringify-keys",
    "signature": "stringify-keys form",
    "doc": "Walk the data structure converting keyword/symbol map keys into strings.",
    "origin": "walk",
    "examples": [
      "(walk::stringify-keys {:user {:name \"Ada\"}}) ; => {\"user\" {\"name\" \"Ada\"}}",
      "(walk::stringify-keys [{:a 1}]) ; => [{\"a\" 1}]"
    ]
  },
  {
    "name": "subs",
    "signature": "subs s start [end]",
    "doc": "Return the substring beginning at start (inclusive) and ending at end (exclusive) when provided; indexes are in characters.",
    "origin": "core",
    "examples": [
      "(subs \"clove\" 2) ; => \"ove\"",
      "(subs \"clove\" 1 4) ; => \"lov\""
    ]
  },
  {
    "name": "subvec",
    "signature": "subvec coll start [end]",
    "doc": "Return a vector of items from coll starting at start (inclusive) up to end (exclusive); end defaults to the length. Indexes must be within bounds and non-negative. Seq inputs are realized before slicing.",
    "origin": "core",
    "examples": [
      "(subvec [0 1 2 3] 1 3) ; => [1 2]",
      "(subvec [10 20 30] 1) ; => [20 30]"
    ]
  },
  {
    "name": "swap!",
    "signature": "swap! atom f & args",
    "doc": "Alias of atom-update!; atomically replace the atom value by applying f to it with args.",
    "origin": "core",
    "examples": [
      "(let [c (atom 0)] (swap! c inc)) ; => 1",
      "(let [c (atom 1)] (swap! c + 5) (deref c)) ; => 6"
    ]
  },
  {
    "name": "symbol",
    "signature": "symbol x",
    "doc": "Coerce the value into a symbol.",
    "origin": "core",
    "examples": [
      "(symbol \"foo\") ; => foo",
      "(symbol :bar) ; => bar"
    ]
  },
  {
    "name": "symbol?",
    "signature": "symbol? x",
    "doc": "True when the value is a symbol.",
    "origin": "core",
    "examples": [
      "(symbol? 'a) ; => true"
    ]
  },
  {
    "name": "tagged?",
    "signature": "tagged? type value",
    "doc": "Return true when value carries a matching :type tag (does not validate required fields).",
    "origin": "core",
    "examples": [
      "(tagged? :core::Map {:type 'core::Map}) ; => true",
      "(tagged? :core::Map {}) ; => false"
    ]
  },
  {
    "name": "take",
    "signature": "take n coll",
    "doc": "Return a vector of the first n items of coll (or fewer if coll is short). When coll is a seq, only up to n elements are pulled before materializing; use core::take if you need to keep the result lazy.",
    "origin": "core",
    "examples": [
      "(take 2 [1 2 3]) ; => [1 2]",
      "(take 3 (repeatedly (fn [] :tick))) ; => [:tick :tick :tick]"
    ]
  },
  {
    "name": "take-nth",
    "signature": "take-nth n coll",
    "doc": "Return every nth item from coll; seq inputs yield a lazy sequence.",
    "origin": "core",
    "examples": [
      "(take-nth 2 [1 2 3 4 5]) ; => [1 3 5]",
      "(vec (take-nth 3 (range 10))) ; => [0 3 6 9]"
    ]
  },
  {
    "name": "take-last",
    "signature": "take-last n coll",
    "doc": "Return a vector of the last n items from coll (or all items if n exceeds the length). Seq inputs are fully realized to produce the tail.",
    "origin": "core",
    "examples": [
      "(take-last 2 [1 2 3 4]) ; => [3 4]",
      "(take-last 3 (range 5)) ; => [2 3 4]"
    ]
  },
  {
    "name": "take-while",
    "signature": "take-while pred coll",
    "doc": "Return a vector of items from the start of coll while pred returns truthy. When coll is a seq, elements are pulled until pred fails or the seq ends; a never-false predicate on an infinite seq will not terminate. Use core::take-while if you need to keep the result lazy. Supports [pat coll] sugar.",
    "origin": "core",
    "examples": [
      "(vec (take-while #(< % 3) [0 1 2 3 0])) ; => [0 1 2]",
      "(take-while string? [\"x\" \"y\" 1]) ; => [\"x\" \"y\"]",
      "(take-while #(< % 5) (iterate inc 0)) ; => [0 1 2 3 4]",
      "(vec (take-while [x [0 1 2 3 0]] (< x 3))) ; => [0 1 2]"
    ]
  },
  {
    "name": "task-cancel!",
    "signature": "task-cancel! task",
    "doc": "Request cancellation of the task (currently returns false because tasks cannot be interrupted once started).",
    "origin": "core",
    "examples": [
      "(task-cancel! (spawn (fn [] (time::sleep 100ms) 0))) ; => false",
      "(task-cancel! (spawn (fn [] 1))) ; => false"
    ]
  },
  {
    "name": "task-deref",
    "signature": "task-deref task",
    "doc": "Wait for a task to complete and return its result (or throw on error).",
    "origin": "core",
    "examples": [
      "(task-deref (spawn (fn [] 42))) ; => 42",
      "(task-deref (spawn (fn [] (time::sleep 5ms) :ok))) ; => :ok"
    ]
  },
  {
    "name": "task-done?",
    "signature": "task-done? task",
    "doc": "Return true once the task has finished running.",
    "origin": "core",
    "examples": [
      "(let [t (spawn (fn [] (time::sleep 100ms) 0))] (task-done? t)) ; => false",
      "(let [t (spawn (fn [] 1))] (task-deref t) (task-done? t)) ; => true"
    ]
  },
  {
    "name": "task?",
    "signature": "task? value",
    "doc": "True when value is a task handle.",
    "origin": "core",
    "examples": [
      "(task? (spawn (fn [] 0))) ; => true",
      "(task? (future (fn [] 0))) ; => false"
    ]
  },
  {
    "name": "test::clear!",
    "signature": "test::clear!",
    "doc": "Remove all registered test definitions.",
    "origin": "test",
    "examples": [
      "(do (test::clear!) (test::run-tests)) ; => {:fail 0 :pass 0 :results []}"
    ]
  },
  {
    "name": "test::deftest",
    "signature": "test::deftest name fn",
    "doc": "Register a named test function that will be executed by test::run-tests.",
    "origin": "test",
    "examples": [
      "(test::deftest :math (fn [] (test::is (= 4 (+ 2 2))))) ; => true",
      "(do (test::deftest :truth (fn [] (test::is true))) (count (:results (test::run-tests)))) ; => 1"
    ]
  },
  {
    "name": "test::is",
    "signature": "test::is expr\ntest::is expected actual\ntest::is expected actual msg",
    "doc": "Assertion helper: with one argument require it be truthy; with two or three arguments compare expected and actual optionally with a message.",
    "origin": "test",
    "examples": [
      "(test::is true) ; => true",
      "(test::is 4 (+ 2 2)) ; => true"
    ]
  },
  {
    "name": "test::run-tests",
    "signature": "test::run-tests",
    "doc": "Execute all registered tests and return {:pass n :fail n :results [{:name ... :status ... :error ...}]}.",
    "origin": "test",
    "examples": [
      "(>= (-> (test::run-tests) :pass) 0) ; => true",
      "(map? (test::run-tests)) ; => true"
    ]
  },
  {
    "name": "test::testing",
    "signature": "test::testing label fn",
    "doc": "Run fn while annotating failures with the given label (string or symbol).",
    "origin": "test",
    "examples": [
      "(test::testing \"math\" (fn [] (test::is (= 4 (+ 2 2))))) ; => true",
      "(test::testing :section (fn [] (test::is true))) ; => true"
    ]
  },
  {
    "name": "term::raw-mode!",
    "signature": "term::raw-mode! on?",
    "doc": "Enable or disable terminal raw mode; returns nil.",
    "origin": "term",
    "examples": [
      "(term::raw-mode! false) ; => nil"
    ]
  },
  {
    "name": "term::read-key",
    "signature": "term::read-key [timeout]",
    "doc": "Read a single key event; with no timeout it blocks, with a non-negative integer (milliseconds) or duration it returns nil on timeout. Returns strings like \"up\", \"down\", \"esc\", \"enter\", or \"ctrl-x\".",
    "origin": "term",
    "examples": [
      "(term::read-key 0) ; => nil",
      "(term::read-key 50ms) ; => nil"
    ]
  },
  {
    "name": "term::with-raw-mode",
    "signature": "term::with-raw-mode f",
    "doc": "Run f while raw mode is enabled, restoring the previous state afterward; returns f's result.",
    "origin": "term",
    "examples": [
      "(term::with-raw-mode (fn [] (term::read-key 0))) ; => nil"
    ]
  },
  {
    "name": "throw",
    "signature": "throw value",
    "doc": "Raise a runtime error with the given value.",
    "origin": "special form",
    "examples": [
      "(try (throw (runtime-error \"boom\")) (catch RuntimeError e e)) ; => \"boom\""
    ]
  },
  {
    "name": "time",
    "signature": "time callable",
    "doc": "Execute the zero-arity callable, returning a map with :result, :elapsed-ms, :avg-ms, and :runs (milliseconds as float).",
    "origin": "core",
    "examples": [
      "(get (time (fn [] (+ 1 2))) :result) ; => 3",
      "(get (time (fn [] 0)) :runs) ; => 1"
    ]
  },
  {
    "name": "time::between",
    "signature": "time::between start end",
    "doc": "Return a duration value representing the absolute difference between two instants (milliseconds since epoch).",
    "origin": "time",
    "examples": [
      "(time::between 0 2000) ; => 2s",
      "(sec (time::between 1000 1600)) ; => 0.6"
    ]
  },
  {
    "name": "time::format",
    "signature": "time::format instant pattern",
    "doc": "Format an instant (epoch millis) using chrono/strftime-style pattern strings.",
    "origin": "time",
    "examples": [
      "(time::format 0 \"%Y-%m-%d\") ; => \"1970-01-01\"",
      "(time::format 1577836800000 \"%Y\") ; => \"2020\""
    ]
  },
  {
    "name": "time::instant",
    "signature": "time::instant value",
    "doc": "Normalize an instant value (int or float milliseconds) without modification.",
    "origin": "time",
    "examples": [
      "(time::instant 42) ; => 42",
      "(time::instant 3.5) ; => 3.5"
    ]
  },
  {
    "name": "time::minus",
    "signature": "time::minus instant duration",
    "doc": "Subtract a duration from an instant, returning epoch milliseconds.",
    "origin": "time",
    "examples": [
      "(time::minus 5000 2s) ; => 3000",
      "(time::minus 2000 500ms) ; => 1500"
    ]
  },
  {
    "name": "time::now",
    "signature": "time::now",
    "doc": "Return the current system time in milliseconds since the Unix epoch.",
    "origin": "time",
    "examples": [
      "(<= 0 (time::now)) ; => true",
      "(let [start (time::now)] (>= (time::now) start)) ; => true"
    ]
  },
  {
    "name": "time::parse",
    "signature": "time::parse text",
    "doc": "Parse an ISO-8601 timestamp (or RFC3339) into epoch milliseconds.",
    "origin": "time",
    "examples": [
      "(time::parse \"1970-01-01T00:00:00Z\") ; => 0",
      "(time::parse \"2020-01-01T00:00:00Z\") ; => 1577836800000"
    ]
  },
  {
    "name": "time::plus",
    "signature": "time::plus instant duration",
    "doc": "Add a duration to an instant, returning epoch milliseconds.",
    "origin": "time",
    "examples": [
      "(time::plus 0 2s) ; => 2000",
      "(time::plus 1577836800000 1d) ; => 1577923200000"
    ]
  },
  {
    "name": "time::sleep",
    "signature": "time::sleep duration",
    "doc": "Sleep for the given duration value (milliseconds granularity); returns true unless interrupted.",
    "origin": "time",
    "examples": [
      "(time::sleep 5ms) ; => true",
      "(time::sleep 0ms) ; => true"
    ]
  },
  {
    "name": "duration",
    "signature": "duration magnitude unit",
    "doc": "Create a Duration value from a numeric magnitude and a unit keyword/string (:ms/:sec/:min/:hour/:day/:week/:year).",
    "origin": "duration",
    "examples": [
      "(duration 10 :ms) ; => 10ms",
      "(duration 1.5 :sec) ; => 1500ms"
    ]
  },
  {
    "name": "duration-ms",
    "signature": "duration-ms magnitude",
    "doc": "Return a Duration representing magnitude milliseconds (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-ms 250) ; => 250ms",
      "(duration-ms 1000) ; => 1s"
    ]
  },
  {
    "name": "duration-sec",
    "signature": "duration-sec magnitude",
    "doc": "Return a Duration representing magnitude seconds (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-sec 2) ; => 2s",
      "(duration-sec 0.5) ; => 500ms"
    ]
  },
  {
    "name": "duration-min",
    "signature": "duration-min magnitude",
    "doc": "Return a Duration representing magnitude minutes (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-min 2) ; => 2m",
      "(duration-min 1.5) ; => 90s"
    ]
  },
  {
    "name": "duration-hour",
    "signature": "duration-hour magnitude",
    "doc": "Return a Duration representing magnitude hours (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-hour 1) ; => 1h",
      "(duration-hour 1.5) ; => 90m"
    ]
  },
  {
    "name": "duration-day",
    "signature": "duration-day magnitude",
    "doc": "Return a Duration representing magnitude days (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-day 2) ; => 2d",
      "(duration-day 0.5) ; => 12h"
    ]
  },
  {
    "name": "duration-week",
    "signature": "duration-week magnitude",
    "doc": "Return a Duration representing magnitude weeks (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-week 1) ; => 1w",
      "(duration-week 1.5) ; => 252h"
    ]
  },
  {
    "name": "duration-year",
    "signature": "duration-year magnitude",
    "doc": "Return a Duration representing magnitude years (supports ints and floats).",
    "origin": "duration",
    "examples": [
      "(duration-year 1) ; => 1y",
      "(duration-year 0.5) ; => 4380h"
    ]
  },
  {
    "name": "ms",
    "signature": "ms duration",
    "doc": "Return the duration expressed in milliseconds as a number (int when whole, float when fractional).",
    "origin": "duration",
    "examples": [
      "(ms 5s) ; => 5000",
      "(ms 1500ms) ; => 1500"
    ]
  },
  {
    "name": "sec",
    "signature": "sec duration",
    "doc": "Return the duration expressed in seconds as a number (int when whole, float when fractional).",
    "origin": "duration",
    "examples": [
      "(sec 3s) ; => 3",
      "(sec 1500ms) ; => 1.5"
    ]
  },
  {
    "name": "hour",
    "signature": "hour duration",
    "doc": "Return the duration expressed in hours as a number (int when whole, float when fractional).",
    "origin": "duration",
    "examples": [
      "(hour 2h) ; => 2",
      "(hour 90m) ; => 1.5"
    ]
  },
  {
    "name": "day",
    "signature": "day duration",
    "doc": "Return the duration expressed in days as a number (int when whole, float when fractional).",
    "origin": "duration",
    "examples": [
      "(day 48h) ; => 2",
      "(day 12h) ; => 0.5"
    ]
  },
  {
    "name": "week",
    "signature": "week duration",
    "doc": "Return the duration expressed in weeks as a number (int when whole, float when fractional).",
    "origin": "duration",
    "examples": [
      "(week 2w) ; => 2",
      "(week 3d) ; => 0.42857142857142855"
    ]
  },
  {
    "name": "year",
    "signature": "year duration",
    "doc": "Return the duration expressed in years as a number (int when whole, float when fractional).",
    "origin": "duration",
    "examples": [
      "(year 2y) ; => 2",
      "(year 4380h) ; => 0.5"
    ]
  },
  {
    "name": "timeout",
    "signature": "timeout millis",
    "doc": "Return a channel that closes after the given number of milliseconds (nil means zero).",
    "origin": "core",
    "examples": [
      "(timeout 10) ; => #<chan id=1 cap=0 len=0 closed=false>",
      "(chan-take! (timeout 0)) ; => nil"
    ]
  },
  {
    "name": "toml::generate",
    "signature": "toml::generate value",
    "doc": "Convert the value into TOML text (returned as a string).",
    "origin": "config",
    "examples": [
      "(toml::generate {:db {:port 5432}}) ; => \"[db]\nport = 5432\n\"",
      "(toml::generate {:values [1 2]}) ; => \"values = [1, 2]\n\""
    ]
  },
  {
    "name": "toml::parse",
    "signature": "toml::parse text",
    "doc": "Parse TOML text into the corresponding value.",
    "origin": "config",
    "examples": [
      "(toml::parse \"answer = 42\n\") ; => {\"answer\" 42}",
      "(toml::parse \"[db]\nport = 5432\n\") ; => {\"db\" {\"port\" 5432}}"
    ]
  },
  {
    "name": "toml::read-file",
    "signature": "toml::read-file path",
    "doc": "Read a file and parse it as TOML.",
    "origin": "config",
    "examples": [
      "(toml::read-file \"data::fixtures/doc_examples/config/settings.toml\") ; => {\"settings\" {\"name\" \"demo\" \"port\" 8080}}",
      "(map? (toml::read-file \"data::fixtures/doc_examples/config/settings.toml\")) ; => true"
    ]
  },
  {
    "name": "toml::write-file",
    "signature": "toml::write-file path value",
    "doc": "Write value to the file at path as TOML text (returns path).",
    "origin": "config",
    "examples": [
      "(toml::write-file \"tmp/out.toml\" {:ok true}) ; => \"tmp/out.toml\"",
      "(toml::write-file \"tmp/list.toml\" {:values [1 2]}) ; => \"tmp/list.toml\""
    ]
  },
  {
    "name": "trampoline",
    "signature": "trampoline f & args",
    "doc": "Call f with args until the result is no longer callable; returns the final value.",
    "origin": "core",
    "examples": [
      "(defn step [n] (if (< n 3) #(step (inc n)) n)) (trampoline step 0) ; => 3",
      "(trampoline (fn [] 42)) ; => 42"
    ]
  },
  {
    "name": "tree-seq",
    "signature": "tree-seq branch? children root",
    "doc": "Return a depth-first sequence of nodes starting at root; branch? decides which nodes have children.",
    "origin": "core",
    "examples": [
      "(tree-seq #(contains? % :kids) #(get % :kids []) {:v 1 :kids [{:v 2}]}) ; => ({:kids [{:v 2}] :v 1} {:v 2})",
      "(vec (tree-seq map? #(get % :children []) {:v 1 :children [{:v 2} {:v 3}]})) ; => [{:children [{:v 2} {:v 3}] :v 1} {:v 2} {:v 3}]"
    ]
  },
  {
    "name": "trim",
    "signature": "trim [s]",
    "doc": "Remove leading and trailing Unicode whitespace from the string.",
    "origin": "string",
    "examples": [
      "(trim \"  clove  \") ; => \"clove\"",
      "(trim \"\nhello\t\") ; => \"hello\""
    ]
  },
  {
    "name": "trim-newline",
    "signature": "trim-newline s",
    "doc": "Remove a single trailing newline (and optional carriage return) from s.",
    "origin": "string",
    "examples": [
      "(trim-newline \"line\n\") ; => \"line\"",
      "(trim-newline \"line\r\n\") ; => \"line\""
    ]
  },
  {
    "name": "triml",
    "signature": "triml s",
    "doc": "Remove leading Unicode whitespace from the string.",
    "origin": "string",
    "examples": [
      "(triml \"  clove\") ; => \"clove\"",
      "(triml \"\n\tdata\") ; => \"data\""
    ]
  },
  {
    "name": "trimr",
    "signature": "trimr s",
    "doc": "Remove trailing Unicode whitespace from the string.",
    "origin": "string",
    "examples": [
      "(trimr \"clove  \") ; => \"clove\"",
      "(trimr \"data\n\t\") ; => \"data\""
    ]
  },
  {
    "name": "true?",
    "signature": "true? x",
    "doc": "True only for the literal true.",
    "origin": "core",
    "examples": [
      "(true? true) ; => true"
    ]
  },
  {
    "name": "err",
    "signature": "err form*",
    "doc": "Try clause for handling errors; only valid at the end of try or any body. The error value is available as ?.",
    "origin": "special form",
    "examples": [
      "(try (throw 1) (err ?)) ; => 1",
      "(do (throw 2) (err ?)) ; => 2",
      "(do (defn f [] (throw 3) (err ?)) (f)) ; => 3"
    ]
  },
  {
    "name": "fin",
    "signature": "fin form*",
    "doc": "Try clause for cleanup; runs once when leaving try or an implicit body try. Only valid at the end of try or any body.",
    "origin": "special form",
    "examples": [
      "(do (def x (atom 0)) (try 1 (fin (atom-set! x 9))) @x) ; => 9",
      "(do (def x (atom 0)) (do 1 (fin (atom-set! x 7))) @x) ; => 7"
    ]
  },
  {
    "name": "try",
    "signature": "try body* (catch ...) (finally ...) | try body* (err ...) (fin ...) | try body+ on-error | try body+ on-finally | try body+ on-error on-finally | try [bindings] expr on-error on-finally",
    "doc": "Evaluate expressions with catch/finally blocks, explicit err/fin clauses, or use short forms with handler/finally. Short forms require trailing callable(s) in order [on-error][on-finally].",
    "origin": "special form",
    "examples": [
      "(try (/ 1 0) (catch RuntimeError e :fail)) ; => :fail",
      "(try (throw 1) (fn [e] 42)) ; => 42",
      "(try [i 0] (throw 7) (fn [e] (+ i e)) (fn [] i)) ; => 7"
    ]
  },
  {
    "name": "type",
    "signature": "type value",
    "doc": "Return the namespaced type symbol for the value (alias of type-of).",
    "origin": "core",
    "examples": [
      "(type 10) ; => :core::Int",
      "(type (promise)) ; => :core::Promise"
    ]
  },
  {
    "name": "type-of",
    "signature": "type-of value",
    "doc": "Return the fully-qualified type symbol describing value.",
    "origin": "core",
    "examples": [
      "(type-of 10) ; => :core::Int",
      "(type-of {:a 1}) ; => :core::Map"
    ]
  },
  {
    "name": "unsigned-bit-shift-right",
    "signature": "unsigned-bit-shift-right value bits",
    "doc": "Logical right shift (fills with zeros) treating the integer as unsigned.",
    "origin": "core",
    "examples": [
      "(unsigned-bit-shift-right 16 2) ; => 4",
      "(unsigned-bit-shift-right -2 1) ; => 9223372036854775807"
    ]
  },
  {
    "name": "update",
    "signature": "update map key f & args",
    "doc": "Apply f to the existing value (or nil) at key with optional extra args.",
    "origin": "core",
    "examples": [
      "(update {:a 1} :a inc) ; => {:a 2}"
    ]
  },
  {
    "name": "update-in",
    "signature": "update-in map path f & args",
    "doc": "Apply f to the value found at path (creating maps as needed) and assoc the result.",
    "origin": "core",
    "examples": [
      "(update-in {:stats {:views 1}} [:stats :views] + 4) ; => {:stats {:views 5}}",
      "(update-in {:user {:tags []}} [:user :tags] conj :admin) ; => {:user {:tags [:admin]}}"
    ]
  },
  {
    "name": "upper-case",
    "signature": "upper-case [s]",
    "doc": "Return the upper-case form of the string.",
    "origin": "string",
    "examples": [
      "(upper-case \"clove\") ; => \"CLOVE\"",
      "(upper-case \"MiXeD\") ; => \"MIXED\""
    ]
  },
  {
    "name": "val",
    "signature": "val map-entry",
    "doc": "Return the value part of a map entry or pair.",
    "origin": "core",
    "examples": [
      "(val [:a 10]) ; => 10",
      "(val (first {:k 1})) ; => 1"
    ]
  },
  {
    "name": "vals",
    "signature": "vals [m]",
    "doc": "Return the values of a map as a sequence.",
    "origin": "core",
    "examples": [
      "(vec (sort (vals {:a 2 :b 1}))) ; => [1 2]"
    ]
  },
  {
    "name": "vary-meta",
    "signature": "vary-meta value f & args",
    "doc": "Call f with the current metadata and args, store the returned metadata on the value, and return the value.",
    "origin": "core",
    "examples": [
      "(let [v [1]] (with-meta v {:tag :vec}) (vary-meta v assoc :extra true) (meta v)) ; => {:extra true :tag :vec}",
      "(let [v [1]] (vary-meta v (fn [_] {:tag :fresh})) (meta v)) ; => {:tag :fresh}"
    ]
  },
  {
    "name": "vec",
    "signature": "vec coll",
    "doc": "Coerce the collection into a vector (maps become vectors of key/value vectors, strings become vectors of one-character strings).",
    "origin": "core",
    "examples": [
      "(vec (list 1 2 3)) ; => [1 2 3]",
      "(vec {:a 1}) ; => [[:a 1]]"
    ]
  },
  {
    "name": "vector",
    "signature": "vector & values",
    "doc": "Create a vector from the supplied values.",
    "origin": "core",
    "examples": [
      "(vector 1 2) ; => [1 2]"
    ]
  },
  {
    "name": "vector?",
    "signature": "vector? x",
    "doc": "True when the value is a vector.",
    "origin": "core",
    "examples": [
      "(vector? [1]) ; => true"
    ]
  },
  {
    "name": "walk::walk",
    "signature": "walk inner outer form",
    "doc": "Generic data walk: apply inner to each element recursively, then apply outer to the result.",
    "origin": "walk",
    "examples": [
      "(walk::walk (fn [x] (if (number? x) (* x 2) x)) identity [1 {:x 2}]) ; => [2 {:x 4}]",
      "(walk::walk walk::keywordize-keys walk::stringify-keys {:user {:name \"Ada\"}}) ; => {\"user\" {\"name\" \"Ada\"}}"
    ]
  },
  {
    "name": "when",
    "signature": "when test body",
    "doc": "Evaluate body when test is truthy.",
    "origin": "special form",
    "examples": [
      "(when true :ok) ; => :ok"
    ]
  },
  {
    "name": "when-let",
    "signature": "when-let [binding test] body",
    "doc": "Evaluate body with binding when test is truthy; nil stops execution.",
    "origin": "special form",
    "examples": [
      "(when-let [x 1] (+ x 1)) ; => 2"
    ]
  },
  {
    "name": "when-not",
    "signature": "when-not test body",
    "doc": "Evaluate body when test is falsy.",
    "origin": "special form",
    "examples": [
      "(when-not false :ok) ; => :ok"
    ]
  },
  {
    "name": "while",
    "signature": "while test body",
    "doc": "Evaluate body repeatedly while test is truthy; returns nil.",
    "origin": "special form",
    "examples": [
      "(while false (println :nope)) ; => nil"
    ]
  },
  {
    "name": "with-dyn",
    "signature": "with-dyn var value body",
    "doc": "Temporarily bind a dynamic var for the duration of body.",
    "origin": "special form",
    "examples": [
      "(comment (with-dyn *my-var* 1 (println *my-var*))) ; => nil ; Temporarily bind a dynamic var"
    ]
  },
  {
    "name": "with-meta",
    "signature": "with-meta value meta-map",
    "doc": "Attach metadata to the value (stored out of band and retrievable via meta) and return the value.",
    "origin": "core",
    "examples": [
      "(let [v [1]] (with-meta v {:tag :vec}) (meta v)) ; => {:tag :vec}",
      "(with-meta :v {:doc \"hi\"}) ; => :v"
    ]
  },
  {
    "name": "with-open",
    "signature": "with-open [bindings] & body",
    "doc": "Evaluate bindings, run body, then close bound resources in reverse order (using :close!/ :close metadata, close!/close in scope, or channel close).",
    "origin": "special form",
    "examples": [
      "(with-open [c (chan)] (chan-put! c :value)) ; => true"
    ]
  },
  {
    "name": "with-redefs",
    "signature": "with-redefs [bindings] body",
    "doc": "Temporarily redefine vars during the execution of body.",
    "origin": "special form",
    "examples": [
      "(with-redefs [println (fn [& _] :mocked)] (println)) ; => :mocked"
    ]
  },
  {
    "name": "with-redefs-fn",
    "signature": "with-redefs-fn bindings f",
    "doc": "Return a function that, when called, executes with temporary var redefinitions applied.",
    "origin": "special form",
    "examples": [
      "((with-redefs-fn [println (fn [& _] :mocked)] println)) ; => :mocked"
    ]
  },
  {
    "name": "yaml::generate",
    "signature": "yaml::generate value",
    "doc": "Convert the value into YAML text (compact).",
    "origin": "yaml",
    "examples": [
      "(yaml::generate {:a 1}) ; => \"a: 1\n\"",
      "(yaml::generate {:items [1 2]}) ; => \"items:\n  - 1\n  - 2\n\""
    ]
  },
  {
    "name": "yaml::generate-pretty",
    "signature": "yaml::generate-pretty value",
    "doc": "Return YAML text (pretty-printed).",
    "origin": "yaml",
    "examples": [
      "(yaml::generate-pretty {:a 1}) ; => \"a: 1\n\""
    ]
  },
  {
    "name": "yaml::parse",
    "signature": "yaml::parse text",
    "doc": "Parse YAML text into the corresponding value.",
    "origin": "yaml",
    "examples": [
      "(yaml::parse \"a: 1\n\") ; => {\"a\" 1}",
      "(yaml::parse \"items:\n  - 1\") ; => {\"items\" [1]}"
    ]
  },
  {
    "name": "yaml::read-file",
    "signature": "yaml::read-file path",
    "doc": "Read a file and parse it as YAML.",
    "origin": "yaml",
    "examples": [
      "(yaml::read-file \"data::fixtures/doc_examples/config/settings.yaml\") ; => {\"settings\" {\"name\" \"demo\" \"port\" 8080}}",
      "(map? (yaml::read-file \"data::fixtures/doc_examples/config/settings.yaml\")) ; => true"
    ]
  },
  {
    "name": "yaml::write-file",
    "signature": "yaml::write-file path value",
    "doc": "Write value to the file at path as YAML text (returns path).",
    "origin": "yaml",
    "examples": [
      "(yaml::write-file \"tmp/out.yaml\" {:ok true}) ; => \"tmp/out.yaml\"",
      "(yaml::write-file \"tmp/list.yaml\" {:values [1 2]}) ; => \"tmp/list.yaml\""
    ]
  },
  {
    "name": "zero?",
    "signature": "zero? n",
    "doc": "Return true when the numeric argument is exactly zero.",
    "origin": "core",
    "examples": [
      "(zero? 0) ; => true",
      "(zero? 0.5) ; => false"
    ]
  },
  {
    "name": "zipmap",
    "signature": "zipmap keys vals",
    "doc": "Create a map from keys and vals, truncating to the length of the shorter input.",
    "origin": "core",
    "examples": [
      "(zipmap [:a :b] [1 2]) ; => {:a 1 :b 2}",
      "(zipmap [:x :y :z] (range 2)) ; => {:x 0 :y 1}"
    ]
  },
  {
    "name": "int",
    "signature": "int n",
    "doc": "Convert number to integer (truncating toward zero).",
    "origin": "core",
    "examples": [
      "(int 1.9) ; => 1",
      "(int -1.2) ; => -1"
    ]
  },
  {
    "name": "float",
    "signature": "float n",
    "doc": "Convert number to floating point.",
    "origin": "core",
    "examples": [
      "(float 2) ; => 2.0"
    ]
  },
  {
    "name": "float?",
    "signature": "float? v",
    "doc": "True when v is a float.",
    "origin": "core",
    "examples": [
      "(float? 1.0) ; => true",
      "(float? 1) ; => false"
    ]
  },
  {
    "name": "shuffle",
    "signature": "shuffle coll",
    "doc": "Return a random permutation of the items as a vector.",
    "origin": "core",
    "examples": [
      "(vec (sort (shuffle [1 2 3]))) ; => [1 2 3]"
    ]
  },
  {
    "name": "set::difference",
    "signature": "difference set & sets",
    "doc": "Return the difference of set and the rest.",
    "origin": "set",
    "examples": [
      "(set::difference #{1 2 3} #{2 3}) ; => #{1}"
    ]
  },
  {
    "name": "set::union",
    "signature": "union & sets",
    "doc": "Return the union of the given sets.",
    "origin": "set",
    "examples": [
      "(set::union #{1 2} #{2 3}) ; => #{1 2 3}"
    ]
  },
  {
    "name": "set::intersection",
    "signature": "intersection & sets",
    "doc": "Return the intersection of the given sets.",
    "origin": "set",
    "examples": [
      "(set::intersection #{1 2} #{2 3}) ; => #{2}"
    ]
  },
  {
    "name": "set::select",
    "signature": "select pred set",
    "doc": "Return the elements of set for which pred is true.",
    "origin": "set",
    "examples": [
      "(set::select odd? #{1 2 3 4}) ; => #{1 3}"
    ]
  },
  {
    "name": "set::project",
    "signature": "project xrel ks",
    "doc": "For a set of maps, return a set of maps with only the given keys.",
    "origin": "set",
    "examples": [
      "(set::project #{{:a 1 :b 2} {:a 2 :b 3}} [:a]) ; => #{{:a 1} {:a 2}}"
    ]
  },
  {
    "name": "set::join",
    "signature": "join xrel yrel & rest",
    "doc": "Natural join of relations xrel and yrel; optional keymap for key renames.",
    "origin": "set",
    "examples": [
      "(set::join #{{:a 1} {:a 2}} #{{:a 2 :b 3}}) ; => #{{:a 2 :b 3}}"
    ]
  },
  {
    "name": "set::rename",
    "signature": "rename xrel keymap",
    "doc": "For a set of maps, rename keys according to keymap.",
    "origin": "set",
    "examples": [
      "(set::rename #{{:a 1 :b 2}} {:a :x}) ; => #{{:x 1 :b 2}}"
    ]
  },
  {
    "name": "set::rename-keys",
    "signature": "rename-keys m keymap",
    "doc": "Rename keys in map m according to keymap.",
    "origin": "set",
    "examples": [
      "(set::rename-keys {:a 1 :b 2} {:a :x}) ; => {:x 1 :b 2}"
    ]
  },
  {
    "name": "set::index",
    "signature": "index xrel ks",
    "doc": "Create an index of xrel on keys ks.",
    "origin": "set",
    "examples": [
      "(set::index #{{:a 1 :b 2} {:a 1 :b 3}} [:a]) ; => {{:a 1} #{{:a 1 :b 2} {:a 1 :b 3}}}"
    ]
  },
  {
    "name": "set::map-invert",
    "signature": "map-invert m",
    "doc": "Invert a map's keys and values.",
    "origin": "set",
    "examples": [
      "(set::map-invert {:a 1 :b 2}) ; => {1 :a 2 :b}"
    ]
  },
  {
    "name": "set::subset?",
    "signature": "subset? set1 set2",
    "doc": "Is set1 a subset of set2?",
    "origin": "set",
    "examples": [
      "(set::subset? #{1 2} #{1 2 3}) ; => true"
    ]
  },
  {
    "name": "set::superset?",
    "signature": "superset? set1 set2",
    "doc": "Is set1 a superset of set2?",
    "origin": "set",
    "examples": [
      "(set::superset? #{1 2 3} #{2}) ; => true"
    ]
  },
  {
    "name": "data::diff",
    "signature": "data::diff a b",
    "doc": "Return [only-a only-b both] difference between two values.",
    "origin": "data",
    "examples": [
      "(data::diff {:a 1 :b 2} {:a 1 :b 3}) ; => [{:b 2} {:b 3} {:a 1}]"
    ]
  },
  {
    "name": "p",
    "signature": "p expr | p f a b ...",
    "doc": "Print file:line:col and the value, then return it. With (p f a b ...), evaluates (f a b ...). With a single symbol, calls it only if it is not a local binding and accepts zero arguments.",
    "origin": "special form",
    "examples": [
      "(p + 1 2) ; => 3"
    ]
  },
  {
    "name": "pvalues",
    "signature": "pvalues & exprs",
    "doc": "Evaluate expressions and return their values (evaluated in parallel in Clojure; sequential here).",
    "origin": "special form",
    "examples": [
      "(pvalues (+ 1 2) (* 2 3) (- 10 4)) ; => [3 6 6]"
    ]
  },
  {
    "name": "oop-seg",
    "signature": "oop-seg target name",
    "doc": "Resolve a dot-segment fallback against map/set keys (:name, \"name\", 'name); errors when missing.",
    "origin": "core",
    "examples": [
      "(oop-seg {:timing 1} \"timing\") ; => 1"
    ]
  },
  {
    "name": "native::i32buf-new",
    "signature": "native::i32buf-new capacity",
    "doc": "Create a NativeI32Buf with the given capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-new-main",
    "signature": "native::i32buf-new-main capacity",
    "doc": "Create a thread-affine NativeI32Buf (only the creating thread may access it) with the given capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-begin",
    "signature": "native::i32buf-begin buf",
    "doc": "Lock the buffer for repeated operations on this thread; call native::i32buf-end afterwards.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-end",
    "signature": "native::i32buf-end buf",
    "doc": "Release the lock acquired by native::i32buf-begin.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-len",
    "signature": "native::i32buf-len buf",
    "doc": "Return the number of elements in the buffer.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-capacity",
    "signature": "native::i32buf-capacity buf",
    "doc": "Return the buffer capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-resize!",
    "signature": "native::i32buf-resize! buf new-len fill",
    "doc": "Resize the buffer length; fill with the provided value if needed.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-get",
    "signature": "native::i32buf-get buf idx",
    "doc": "Get the value at the index.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-set!",
    "signature": "native::i32buf-set! buf idx value",
    "doc": "Update the value at the index.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-set-range!",
    "signature": "native::i32buf-set-range! buf start values",
    "doc": "Copy values (vector/list or native i32 buffer) into the buffer starting at start.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-fill!",
    "signature": "native::i32buf-fill! buf value",
    "doc": "Fill the entire buffer with the value.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-fill-xy-step!",
    "signature": "native::i32buf-fill-xy-step! buf start-x start-y count step-x step-y",
    "doc": "Fill the buffer with count (x,y) pairs starting at (start-x,start-y) and stepping by (step-x,step-y). Resizes to count*2.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf->vec",
    "signature": "native::i32buf->vec buf",
    "doc": "Copy the buffer into a Vector and return it (debugging only; not for performance).\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-add!",
    "signature": "native::i32buf-add! buf src\nnative::i32buf-add! buf src scale",
    "doc": "Add src values into the buffer in place. src may be a NativeI32Buf or a vector/list of numbers. When scale is provided, adds src[i] * scale.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-wrap-min!",
    "signature": "native::i32buf-wrap-min! buf min reset",
    "doc": "Replace values smaller than min with reset.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-pack-xy-in-rect!",
    "signature": "native::i32buf-pack-xy-in-rect! out xs ys min-x max-x min-y max-y",
    "doc": "Pack (x,y) pairs from xs/ys into out when inside the rectangle; returns the number of values written. xs/ys may be NativeI32Buf or a vector/list of numbers.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i32buf-step-pack-xy-in-rect!",
    "signature": "native::i32buf-step-pack-xy-in-rect! out xs ys vxs dt wrap-min wrap-reset min-x max-x min-y max-y",
    "doc": "Update xs by vxs*dt (seconds), wrap values smaller than wrap-min to wrap-reset, then pack (x,y) pairs into out when inside the rectangle; returns the number of values written.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-new",
    "signature": "native::f32buf-new capacity",
    "doc": "Create a NativeF32Buf with the given capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-new-main",
    "signature": "native::f32buf-new-main capacity",
    "doc": "Create a thread-affine NativeF32Buf (only the creating thread may access it) with the given capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-begin",
    "signature": "native::f32buf-begin buf",
    "doc": "Lock the buffer for repeated operations on this thread; call native::f32buf-end afterwards.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-end",
    "signature": "native::f32buf-end buf",
    "doc": "Release the lock acquired by native::f32buf-begin.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-len",
    "signature": "native::f32buf-len buf",
    "doc": "Return the number of elements in the buffer.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-capacity",
    "signature": "native::f32buf-capacity buf",
    "doc": "Return the buffer capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-resize!",
    "signature": "native::f32buf-resize! buf new-len fill",
    "doc": "Resize the buffer length; fill with the provided value if needed.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-get",
    "signature": "native::f32buf-get buf idx",
    "doc": "Get the value at the index.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-set!",
    "signature": "native::f32buf-set! buf idx value",
    "doc": "Update the value at the index.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-set-range!",
    "signature": "native::f32buf-set-range! buf start values",
    "doc": "Copy values (vector/list or native f32 buffer) into the buffer starting at start.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf-fill!",
    "signature": "native::f32buf-fill! buf value",
    "doc": "Fill the entire buffer with the value.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::f32buf->vec",
    "signature": "native::f32buf->vec buf",
    "doc": "Copy the buffer into a Vector and return it (debugging only; not for performance).\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-new",
    "signature": "native::i64buf-new capacity",
    "doc": "Create a NativeI64Buf with the given capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-new-main",
    "signature": "native::i64buf-new-main capacity",
    "doc": "Create a thread-affine NativeI64Buf (only the creating thread may access it) with the given capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-begin",
    "signature": "native::i64buf-begin buf",
    "doc": "Lock the buffer for repeated operations on this thread; call native::i64buf-end afterwards.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-end",
    "signature": "native::i64buf-end buf",
    "doc": "Release the lock acquired by native::i64buf-begin.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-len",
    "signature": "native::i64buf-len buf",
    "doc": "Return the number of elements in the buffer.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-capacity",
    "signature": "native::i64buf-capacity buf",
    "doc": "Return the buffer capacity.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-resize!",
    "signature": "native::i64buf-resize! buf new-len fill",
    "doc": "Resize the buffer length; fill with the provided value if needed.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-get",
    "signature": "native::i64buf-get buf idx",
    "doc": "Get the value at the index.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-set!",
    "signature": "native::i64buf-set! buf idx value",
    "doc": "Update the value at the index.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf-set-range!",
    "signature": "native::i64buf-set-range! buf start values",
    "doc": "Copy values (vector/list or native i64 buffer) into the buffer starting at start.\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "native::i64buf->vec",
    "signature": "native::i64buf->vec buf",
    "doc": "Copy the buffer into a Vector and return it (debugging only; not for performance).\nNote: Mutable, reference type; unlike Vector it is not persistent, and is intended for FFI/high-performance use.",
    "origin": "native",
    "examples": []
  },
  {
    "name": "mut",
    "signature": "mut x",
    "doc": "Deep-convert collections to mutable ones; nested map/vector/set values become mutable as well. Note: if you replace a key with assoc!, older references still point to the previous value (by design).",
    "origin": "core",
    "examples": [
      "(mut {:a 1}) ; => #<mut {:a 1}>",
      "(let [world (mut {:player {:x 10 :y 20} :tick 0})]\n  (mut? (get world :player))) ; => true"
    ]
  },
  {
    "name": "imut",
    "signature": "imut x",
    "doc": "Deep-convert collections to immutable ones, freezing any mutable collections.",
    "origin": "core",
    "examples": [
      "(let [m (mut {:a 1})] (imut m)) ; => {:a 1}",
      "(let [world (mut {:tick 1})]\n  (let [snapshot (imut world)] (get snapshot :tick))) ; => 1"
    ]
  },
  {
    "name": "mut?",
    "signature": "mut? x",
    "doc": "Return true when the value is a mutable collection.",
    "origin": "core",
    "examples": [
      "(mut? (mut {:a 1})) ; => true",
      "(mut? {:a 1}) ; => false"
    ]
  },
  {
    "name": "assoc!",
    "signature": "assoc! m k v & kvs",
    "doc": "Destructively associate entries on a mutable or transient map/vector.",
    "origin": "core",
    "examples": [
      "(let [m (mut {:a 1})]\n  (assoc! m :a 2)\n  (get m :a)) ; => 2"
    ]
  },
  {
    "name": "conj!",
    "signature": "conj! coll & xs",
    "doc": "Destructively conjoin items onto a mutable or transient collection. For sets, items are stored as immutable values; mutable collections are rejected (use (imut x)).",
    "origin": "core",
    "examples": [
      "(let [v (mut [1 2])]\n  (conj! v 3 4)\n  v) ; => #<mut [1 2 3 4]>",
      "(let [m (mut {:a 1})]\n  (conj! m [:b 2])\n  (get m :b)) ; => 2",
      "(let [s (mut #{})]\n  (conj! s {:a 1})\n  (contains? s {:a 1})) ; => true"
    ]
  },
  {
    "name": "update!",
    "signature": "update! m k f & args",
    "doc": "Destructively update a value in a mutable or transient map/vector by applying f.",
    "origin": "core",
    "examples": [
      "(let [m (mut {:a 1})]\n  (update! m :a inc)\n  (get m :a)) ; => 2",
      "(let [v (mut [1 2 3])]\n  (update! v 1 (fn [x] (+ x 10)))\n  (get v 1)) ; => 12"
    ]
  },
  {
    "name": "update-in!",
    "signature": "update-in! m path f & args",
    "doc": "Destructively update a nested value in a mutable map/vector by applying f.",
    "origin": "core",
    "examples": [
      "(let [m (mut {:a {:b 1}})]\n  (update-in! m [:a :b] inc)\n  (get-in m [:a :b])) ; => 2",
      "(let [m (mut {})]\n  (update-in! m [:a :b] (fn [_] 1))\n  (get-in m [:a :b])) ; => 1"
    ]
  }
]
