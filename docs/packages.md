# Packages (Phase1)

Japanese version: [packages.ja.md](packages.ja.md)

Phase1 targets **pure Clove libraries**, fetched from Git repositories and made available to `require`.
Native/plugins/docs externalization/fn_meta are not covered here.

## Package ID and namespace

- **Package ID**: `owner/pkg`
- **Namespace root**: `owner::pkg::...`
- **Placement rule** (ns -> path should be obvious)

```
src/<owner>/<pkg>/core.clv
```

Example: `example::flappy::core` -> `src/example/flappy/core.clv`

## install / registry / require

- install target is under `CLOVE_HOME` (defaults to `~/.clove`)

```
~/.clove/pkgs/<owner>/<pkg>/<commit>/
  src/...
  clove-pkg.json
```

- `registry.json` records installed packages
- `require` uses the commit from project lock if present; otherwise the latest `installed_at`

## CLI

```
clove pkg install <git-url> [--pkg owner/pkg] [--rev <ref>] [--force] [--project]
clove pkg list
clove pkg update <owner/pkg> [--rev <ref>] [--force]
clove pkg uninstall <owner/pkg> [--commit <sha>] [--all]
clove pkg sync [--update] [--offline] [--force]
```

- `--rev` is a git ref (tag / commit SHA / branch)
- If `--pkg` is omitted for GitHub URLs, `owner/repo` is assumed
  - If you want a different package name, set `--pkg` explicitly
- For local paths, infer from `clove-pkg.json` `pkg` (if missing, `--pkg` is required)
- Shorthand examples
  - `clove pkg install example/flappy --rev v0.1.0`
  - `clove pkg update example/flappy --rev v0.2.0`
- Add to project (update deps/lock)
  - `clove pkg install example/flappy --rev v0.1.0 --project`
- `pkg uninstall`
  - `--all` removes all installs and deletes the package from registry
  - `--commit` removes only the specified commit
  - without `--commit`, removes the commit with the latest `installed_at`

## Phase1 limitations

- `require` does not auto-download
  - run `clove pkg install ...` first
- dependency files (`deps.clv`, etc.) are not supported
- if project lock exists, it has priority

## Phase2: project deps/lock

Place `clove.deps.json` and `clove.lock.json` in the project to **pin commits per project**
for `require` resolution.

```
// clove.deps.json
{
  "deps": {
    "example/flappy": { "origin": "example/flappy", "rev": "v0.1.0" }
  }
}
```

```
// clove.lock.json
{
  "deps": {
    "example/flappy": { "origin_url": "https://github.com/example/flappy.git", "commit": "<sha>" }
  }
}
```

- `clove pkg sync` resolves deps, installs if needed, and generates lock
  - `--update` re-resolves revs and updates lock
  - `--offline` uses no network and errors if not installed
  - `--force` overwrites origin conflicts or lock differences
- `require` priority
  - commit specified in lock
  - if no lock, the latest `installed_at`

## Package-side deps (transitive)

If a package `clove-pkg.json` includes `deps`, it declares **transitive dependencies**.
`clove pkg sync` resolves the closure from project deps and generates a lock for **the entire closure**.

```
// clove-pkg.json
{
  "pkg": "inakaegg/flappy",
  "ns_root": "inakaegg::flappy",
  "deps": {
    "somebody/util": { "origin": "somebody/util", "rev": "v0.1.0" }
  }
}
```

- `pkg install --project` updates the lock only for the added package and its closure
- If the same package requires different commits, it is an error (dependency conflict)

## Phase3: native plugin bundled packages

For packages that bundle native plugins, assume this layout:

```
repo-root/
  src/<owner>/<pkg>/...
  plugins/<platform>/
    libclove_example.(dylib|so|dll)
```

- `<platform>` is `os-arch` (e.g., `macos-aarch64`, `macos-x86_64`, `linux-x86_64`, `windows-x86_64`)
- `plugins/` root is also searched for compatibility

If `clove.lock.json` exists, **plugin dirs of locked packages are automatically added** to the search path.
However, native plugins under packages must match the `native_plugins` sha256 recorded in lock.
Using `--allow-native-plugins` keeps the old allow-all behavior. Manual `--plugin-dir` still works.

### meta.json (type metadata)

Native plugins should ship `*.meta.json` in the **same directory** as dylib/so/dll.
meta can be generated by `clove plugin write-meta`, and `clove pkg install` will
fallback-generate if missing.

- Example: `plugins/<platform>/clove-sdl2.meta.json`
- LSP resolves plugin dirs from `clove.lock.json` and reads meta
- Overrides via `pluginDirs` / `CLOVE_PLUGIN_DIR` are supported (backward compatible)
- Plugin authors only need `clove-plugin-sdk` and to add `#[clove_fn]` in Rust

---
<!-- NAV:START -->
**Previous:** [CLI (clove / clove fmt / clove build)](tooling/cli.md)
**Next:** [Formatter (fmt / rubocop/syntax_tree)](tooling/formatter.md)
<!-- NAV:END -->

