# dot-chain（`x.(f ?)`）

- 更新日: 2026-01-14

dot-chain は “メソッドチェーン風” の読みやすさのための Reader 構文糖です。

> 使う前に `use-syntax dot-chain true` を有効化してください（環境によってはデフォルト ON）。

## 1. 基本

```clojure
x.(f ?).(g 1 ?).(h ?)
```

- `expr.(...)` を **連結**して書く構文です。
- 各 stage の `?` の位置に **前段の値**が入ります。

### 1.1 stage の条件

- 基本は **`?` または `*?` が必須**です。
- 例外: `.(as x)` / `.(let x)` / `.(repl)` / `.(debug)`
- 記号の意味は短縮関数と同じで、`?` は `%` と同義、`*?` は splat（展開）です。

### 1.2 短縮関数（`#(...)`）との併用

短縮関数の `?`/`%` は **短縮関数の引数プレースホルダ**です。  
dot-chain の `?` は **短縮関数の中には展開されない**ため、段階の引数として `?` を別で置く必要があります。

```clojure
(range 5)
.(filter #(> % 2) ?)
;;          ^ short fn の引数（%）
;;                       ^ dot-chain のプレースホルダ
```

### 1.3 `repl` / `debug` の挿入

`(repl)` / `(debug)` は **`?` を省略しても** その時点の値で REPL を開けます。
`.(repl x)` は `.(let x).repl` の短縮で、`*x` に保存してから REPL を開きます。

```clojure
(range 5)
.(map inc ?)
.(repl)
.(take ? 3)
```

### 1.4 `as` / `let` のディレクティブ

- `.(as x)` はその時点の値を `x` に束縛し、以降の stage 内で参照できます。
- `.(let x)` はその時点の値を `*x` に保存し、値はそのまま次に流します。

## 2. `*?`（apply）

`*?` は “引数を展開して呼ぶ（splat）” ための記法です。

```clojure
x.(f 1 *?)
```

この段階は概ね `(apply f 1 prev)` のように展開されます。  
短縮関数の `*?`（splat）と同じ記号を使います。

> 制約: `*?` は段階のリスト内で **最後の引数** である必要があります。

## 3. 典型例

```clojure
(def result
  (range 10)
  .(shuffle ?)
  .(reverse ?)
  .(take ? 3))

result
```

## 4. `->`/`as->` との違い

- `->`/`as->`: 既存のフォームを順に変形
- dot-chain: `?` を使って “前段の値” を差し込む

どちらも書けるので、チーム内で統一ルールを持つのがおすすめです。

> `(. f g h)` / `(f g h .)` は **関数合成の糖衣**で、dot-chain とは別物です。

## 5. 内部フォーム（`__set-in-chain`）

`.(let x)` などの一部機能は、内部的に `__set-in-chain` へ展開されます。  
これは **評価器の内部用 special form** なので、通常は直接使いません。

---
<!-- NAV:START -->
**前へ:** [indexer: `x[0]`, `x[0 1]`, `x[0,1]`, `x[0||d]`, `a..b`](indexer.ja.md)
**次へ:** [OOP 記法（`obj.method(...)`）](oop_syntax.ja.md)
<!-- NAV:END -->

