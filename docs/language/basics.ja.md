# è¨€èªã®åŸºç¤

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€Clove ã®ã€Œæœ€åˆã«çŸ¥ã£ã¦ãŠããŸã„åŸºæœ¬æ–‡æ³•ã€ã‚’ã–ã£ãã‚Šã¾ã¨ã‚ãŸã‚‚ã®ã§ã™ã€‚

- S å¼ã¨è©•ä¾¡
- ãƒªãƒ†ãƒ©ãƒ«ï¼ˆæ•°å€¤ / æ–‡å­—åˆ— / ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ / æ­£è¦è¡¨ç¾ / Durationï¼‰
- å¤‰æ•°å®šç¾© (`def`, `let`)
- é–¢æ•° (`fn`, `defn`) ã¨å‹ãƒ’ãƒ³ãƒˆ
- åˆ¶å¾¡æ§‹æ–‡ (`if`, `cond`, `when`, `loop` / `recur` ãªã©)
- åå‰ç©ºé–“ (`ns`, `require`)
- REPL ã§ã®ã¡ã‚‡ã£ã¨ã—ãŸæ“ä½œ

è©³ç´°ãªå‹ã‚·ã‚¹ãƒ†ãƒ ã‚„å¤–éƒ¨ã‚¨ãƒ³ã‚¸ãƒ³ã€ä¸¦è¡Œæ©Ÿèƒ½ã¯ä»–ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## 1. S å¼ã¨è©•ä¾¡ãƒ¢ãƒ‡ãƒ«

Clove ã¯ Lisp ãƒ©ã‚¤ã‚¯ãª S å¼ã‚’æŒã¤è¨€èªã§ã™ã€‚  
å¼ã¯ **ãƒªã‚¹ãƒˆ (list)** ã§è¡¨ç¾ã•ã‚Œã€æœ€åˆã®è¦ç´ ãŒã€Œé–¢æ•°ã‚„ special formã€ã€æ®‹ã‚ŠãŒå¼•æ•°ã«ãªã‚Šã¾ã™ã€‚

```clojure
(+ 1 2 3)     ; => 6
(str "a" "b") ; => "ab"
(if cond x y) ; cond ãŒçœŸãªã‚‰ xã€å½ãªã‚‰ y
````

* ãƒªã‚¹ãƒˆã¯ `()` ã§è¡¨ç¾ã•ã‚Œã¾ã™ã€‚
* `(+ 1 2)` ã®ã‚ˆã†ãªå½¢ã‚’ã€Œãƒ•ã‚©ãƒ¼ãƒ  (form)ã€ã¨å‘¼ã³ã¾ã™ã€‚
* è©•ä¾¡ãƒ«ãƒ¼ãƒ«ã®åŸºæœ¬ã¯ Clojure ã«è¿‘ãã€ã€Œå…ˆé ­ã‚’è©•ä¾¡ã—ã¦é–¢æ•°ã‚’æ±ºã‚ã€æ®‹ã‚Šã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã€ã§ã™ã€‚

---

## 2. ãƒªãƒ†ãƒ©ãƒ«

### 2.1 åŸºæœ¬ãƒªãƒ†ãƒ©ãƒ«

* æ•´æ•°: `0`, `42`, `-10`
* æµ®å‹•å°æ•°: `3.14`, `-0.5`, `1.0e3`
* æ–‡å­—åˆ—: `"hello"`, `"ã“ã‚“ã«ã¡ã¯"`
* çœŸå½å€¤: `true`, `false`
* nil: `nil`

`_` ã‚’ä½¿ã£ãŸæ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã‚‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã™ã€‚

```clojure
1_000_000  ; => 1000000
3_600_000  ; ãªã©
```

### 2.2 ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³

* ãƒ™ã‚¯ã‚¿: `[1 2 3]`
* ãƒªã‚¹ãƒˆ: `'(1 2 3)` ã¾ãŸã¯ `(list 1 2 3)`
* ãƒãƒƒãƒ—:

  * Clojure é¢¨: `{:x 1 :y 2}`
  * JSON é¢¨: `{x: 1 y: 2 name: "Taro"}`
* ã‚»ãƒƒãƒˆ: `#{1 2 3}`

```clojure
(def v [1 2 3])
(def m {:x 10 :y 20})

v[0]       ; => 1
m[:x]      ; => 10
(assoc m :x 99) ; => {:x 99 :y 20}
```

JSON é¢¨ãƒãƒƒãƒ—ã§ã¯ã€ã‚­ãƒ¼ãŒã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚

```clojure
{foo: 1 bar: 2}  ; => {:foo 1 :bar 2}
```

### 2.3 æ­£è¦è¡¨ç¾ã¨ Duration

* æ­£è¦è¡¨ç¾:

  * Ruby / JS é¢¨: `/foo.*/`ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
  * æ˜ç¤ºçš„ãªå½¢å¼: `#/foo.*/`ï¼ˆæ›–æ˜§ãªå ´åˆã®å›é¿ç”¨ï¼‰

* Duration:

  * `10ms`, `500ms`, `3s`, `2m`, `1h`, `5d`, `1w`, `1y` ãªã©
  * `_` ä»˜ãã®æ•°å€¤ã‚‚å¯: `1_000ms`
  * æ•°å€¤ã‹ã‚‰ä½œã‚‹å ´åˆã¯ `(duration 0.5 :sec)` ã‚„ `(duration-ms 250)` ãªã©ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚åˆ©ç”¨ã§ãã‚‹

æ­£è¦è¡¨ç¾ã¨ Duration ã®è©³ç´°ã¯åˆ¥ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

* [æ­£è¦è¡¨ç¾ / Duration ãƒªãƒ†ãƒ©ãƒ«](regex_duration.ja.md)

### 2.4 ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®åå‰è§£æ±ºã«ã¤ã„ã¦

Clove ã§ã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§ã™ã€‚`:user::flag` ã®ã‚ˆã†ã«åå‰ç©ºé–“é¢¨ã®è¡¨è¨˜ã¯æ›¸ã‘ã¾ã™ãŒã€ã‚ãã¾ã§æ–‡å­—åˆ—ã®ä¸€éƒ¨ã¨ã—ã¦æ‰±ã‚ã‚Œã€ç‰¹å®šã®åå‰ç©ºé–“ã«ç´ã¥ãã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Clojure ã® `::myns/abc` ã®ã‚ˆã†ãªè‡ªå‹•è§£æ±ºä»˜ãã®ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ä»˜ãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã¯æ„å‘³ãŒç•°ãªã‚‹ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

---

## 3. å¤‰æ•°å®šç¾©ã¨æŸç¸›

### 3.1 `def` â€“ ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«å®šç¾©

```clojure
(def answer 42)

(println answer) ; => 42
```

* ç¾åœ¨ã®åå‰ç©ºé–“ã« `answer` ã‚’å®šç¾©ã—ã¾ã™ã€‚
* å†è©•ä¾¡ã™ã‚‹ã¨å€¤ãŒä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚
* `def` ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«å°‚ç”¨ã§ã™ï¼ˆé–¢æ•°å†…ã§ä½¿ã†ã¨ã‚¨ãƒ©ãƒ¼ï¼‰ã€‚

### 3.2 `let` â€“ ãƒ­ãƒ¼ã‚«ãƒ«æŸç¸›

```clojure
(let [x 10
      y 20]
  (+ x y))    ; => 30
```

* ãƒ™ã‚¯ã‚¿ã§åå‰ã¨å€¤ã‚’äº¤äº’ã«ä¸¦ã¹ã¾ã™ã€‚
* `let` ã®ã‚¹ã‚³ãƒ¼ãƒ—å†…ã ã‘ã§æœ‰åŠ¹ã§ã™ã€‚

### 3.3 `set!` / `redef` â€“ æ—¢å­˜ var ã®æ›´æ–°

```clojure
(def x 1)
(set! x 2)
x ; => 2
```

* `set!` ã¯ **æ—¢å­˜ã®åå‰ç©ºé–“ var** ã‚’æ›´æ–°ã—ã¾ã™ã€‚
* æœªå®šç¾©ã® var ã¸ã® `set!` ã¯ã‚¨ãƒ©ãƒ¼ã§ã™ï¼ˆã‚¿ã‚¤ãƒ—ãƒŸã‚¹æ¤œå‡ºï¼‰ã€‚
* `redef` ã¯ `set!` ã®åˆ¥åã§ã™ã€‚
* ãƒ­ãƒ¼ã‚«ãƒ«æŸç¸›ï¼ˆ`let` ã‚„ `-def`ï¼‰ã‚’ `set!` ã§æ›´æ–°ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

### 3.4 `-def` â€“ ãƒ­ãƒ¼ã‚«ãƒ«æŸç¸›ï¼ˆlet* ç›¸å½“ï¼‰

```clojure
(defn f [x]
  (-def a (+ x 1))
  (-def b (+ a 1))
  (+ a b)) ; => 5 (x=1)
```

* `-def` ã¯é–¢æ•°å†…å°‚ç”¨ã®ãƒ­ãƒ¼ã‚«ãƒ«æŸç¸›ã§ã™ã€‚
* é€æ¬¡æŸç¸›ï¼ˆ`let*` ç›¸å½“ï¼‰ãªã®ã§ã€å‰ã«å®šç¾©ã—ãŸå€¤ã‚’å‚ç…§ã§ãã¾ã™ã€‚

---

## 4. é–¢æ•°

### 4.1 ç„¡åé–¢æ•° `fn`

```clojure
(fn [x] (+ x 1))

((fn [x] (+ x 1)) 10) ; => 11
```

### 4.2 é–¢æ•°å®šç¾© `defn`

```clojure
(defn add :int [x :int y :int]
  (+ x y))

(add 1 2) ; => 3
```

* `defn name <ret-type?> [arg1 <type?> arg2 <type?> ...] body...`
* `defn` ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«å°‚ç”¨ã§ã™ï¼ˆé–¢æ•°å†…ã§ä½¿ã†ã¨ã‚¨ãƒ©ãƒ¼ï¼‰ã€‚
* æˆ»ã‚Šå€¤ãƒ»å¼•æ•°ã®å‹ãƒ’ãƒ³ãƒˆã¯ **ä»»æ„** ã§ã™ãŒã€ä»˜ã‘ã¦ãŠãã¨:

  * ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ (`doc` / `describe`)
  * å°†æ¥çš„ãª LSP / è£œå®Œ
  * ç°¡æ˜“æœ€é©åŒ–ï¼ˆäºˆå®šï¼‰

ã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚

* attr-map ã¯ Clojure åŒæ§˜ã€**åå‰ç›´å¾Œ** ã¾ãŸã¯ **docstring ç›´å¾Œ** ã®ã©ã¡ã‚‰ã«ã‚‚ç½®ã‘ã¾ã™ï¼ˆè¤‡æ•°ç½®ãã®ã¯éå¯¾å¿œï¼‰ã€‚
  * `{:subject-pos N}` ã¾ãŸã¯ `{:subject-pos :last}`/`-1` ã‚’æŒ‡å®šã™ã‚‹ã¨ OOP ãƒã‚§ã‚¤ãƒ³ã§ã®ãƒ¬ã‚·ãƒ¼ãƒä½ç½®ã‚’å›ºå®šã§ãã¾ã™ã€‚
  * ä»˜ä¸ã—ãŸ attr-map ã¯ `(meta fn-name)` ã§ãã®ã¾ã¾å–å¾—ã§ãã¾ã™ï¼ˆè©•ä¾¡ã¯ã•ã‚Œãšãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä»˜ãï¼‰ã€‚

```clojure
(defn greet {:subject-pos :last} "docstring" [name suffix]
  (str name suffix))

(meta greet) ; => {:subject-pos :last}
```

### 4.3 çŸ­ç¸®ãƒ©ãƒ ãƒ€

å®Ÿè£…å´ã«ã¯ã€Œ`#()` å½¢å¼ã®çŸ­ç¸®ãƒ©ãƒ ãƒ€ã€ãŒã‚ã‚Šã¾ã™ï¼ˆ`#(inc %)` ã®ã‚ˆã†ãªæ›¸ãæ–¹ï¼‰ã€‚
ç¾æ™‚ç‚¹ã§ã¯ä»•æ§˜ãŒå¤‰ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€è©³ç´°ãªèª¬æ˜ã¯å‰²æ„›ã—ã¾ã™ã€‚
é€šå¸¸ã® `fn` / `defn` ã‚’å„ªå…ˆã—ã¦ä½¿ã†ã¨å®‰å…¨ã§ã™ã€‚

---

## 5. åˆ¶å¾¡æ§‹æ–‡

ä»£è¡¨çš„ãªã‚‚ã®ã ã‘åˆ—æŒ™ã—ã¾ã™ï¼ˆClojure ã«ã»ã¼è¿‘ã„ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰ã€‚

```clojure
(if cond
  then-expr
  else-expr)

(when cond
  expr1
  expr2
  ...)

(cond
  (= x 0) "zero"
  (= x 1) "one"
  :else   "other") ; _ ã§ã‚‚å¯
```

`loop` / `recur` ã‚‚ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ï¼ˆæœ«å°¾å†å¸°æœ€é©åŒ–ã‚’æ„è­˜ã—ãŸæ›¸ãæ–¹ï¼‰ã€‚

```clojure
(defn sum-to :int [n :int]
  (loop [i 0 acc 0]
    (if (> i n)
      acc
      (recur (inc i) (+ acc i)))))
```

---

## 6. åå‰ç©ºé–“ã¨ `require`

### 6.1 `ns`

```clojure
(ns myapp::core)

(def pi 3.1415)
```

* åå‰ç©ºé–“ã¯ `::` åŒºåˆ‡ã‚Šã§æ›¸ãã¾ã™ã€‚
* æ…£ç¿’ã¨ã—ã¦ã€`myapp/core.clv` â†’ `(ns myapp::core)` ã®ã‚ˆã†ã«
  ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¨åå‰ç©ºé–“ã‚’æƒãˆã‚‹ã®ãŒãŠã™ã™ã‚ã§ã™ã€‚

### 6.2 `require`

```clojure
(ns myapp::ui
  (require myapp::core :as core))

(core::pi) ; => 3.1415
```

Clojure ã¨åŒã˜ã `:as` / `:refer` / `:rename` å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

ã¾ãŸã€`require` ã«æ–‡å­—åˆ—ã‚’æ¸¡ã™ã¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚
ãƒ•ã‚¡ã‚¤ãƒ«å´ã« `(ns ...)` ãŒç„¡ã„å ´åˆã¯ãƒ‘ã‚¹ç”±æ¥ã®æš—é»™ namespace ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚
ã€Œç¾åœ¨ã® namespace ã«å®šç¾©ã‚’æµã—è¾¼ã¿ãŸã„ã€å ´åˆã¯ `load-file` ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚

`:refer` ã¯å€¤ã ã‘ã§ãªãå‹ã‚‚ import ã—ã€`:as` alias ã¯å‹æ³¨é‡ˆã§ã‚‚ `alias::Type` ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚
`defenum` ã¯ `Noop`/`Quit` ã®ã‚ˆã†ãª variant å‹åã‚’æš—é»™ã«ä½œæˆã—ã¾ã™ï¼ˆ`qualified-only` ã®ã¨ãã¯é™¤å¤–ï¼‰ã€‚

---

## 7. REPL ã®ã¡ã‚‡ã„ãƒ†ã‚¯

`clove --repl` ã§ REPL ã‚’èµ·å‹•ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ“ä½œãŒã§ãã¾ã™ã€‚

```clojure
; ã‚·ãƒ³ãƒœãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
:doc map
:doc myapp::core::area

; å€¤ã‚„ã‚·ãƒ³ãƒœãƒ«ã®æƒ…å ±
(describe +)
(describe {:x 1 :y 2})
```

VS Code ã‹ã‚‰ã¯ `Clove: Send Selection to REPL` ã‚³ãƒãƒ³ãƒ‰ã§
ç¾åœ¨ã®ãƒ•ã‚©ãƒ¼ãƒ  / é¸æŠç¯„å›²ã‚’ REPL ã«é€ã‚Šè¾¼ã‚€ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

> REPL ã®è©³ç´°ï¼ˆ` :source` ãªã©ã®æ‹¡å¼µã‚³ãƒãƒ³ãƒ‰ï¼‰ã¯ä»Šå¾Œ `tooling/cli.md` å´ã«ã¾ã¨ã‚ã¦ã„ãã¾ã™ã€‚
> EOF
> fi

######################################

# docs/language/types_enum_match.md

######################################
if [ -e "docs/language/types_enum_match.md" ]; then
echo "[skip] docs/language/types_enum_match.md already exists"
else
echo "[create] docs/language/types_enum_match.md"
cat > docs/language/types_enum_match.md <<'EOF'

# å‹ãƒ»enumãƒ»match

Clove ã¯ã€Œã¾ãšã¯å‹•çš„ãƒ»ãƒãƒƒãƒ—ä¸­å¿ƒã€ã§è¨­è¨ˆã•ã‚ŒãŸ Lisp æ–¹è¨€ã§ã™ãŒã€
`deftype` / `defenum` / `match` ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€è»½é‡ãªä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ï¼ˆADTï¼‰é¢¨ã«æ›¸ã‘ã¾ã™ã€‚

ã“ã®æ–‡æ›¸ã§ã¯ã€ç¾åœ¨å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ä»•æ§˜ã‚’ãƒ™ãƒ¼ã‚¹ã«

* `deftype`ï¼ˆproduct typeï¼‰
* `defenum`ï¼ˆsum type / åˆ—æŒ™ï¼‰
* `match`ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒï¼‰

ã®ä½¿ã„æ–¹ã¨å½¹å‰²ã‚’ã¾ã¨ã‚ã¾ã™ã€‚

> ğŸ’¡ Clojure ã¨ã®é•ã„
>
> * Clove ã«ã¯ `protocol` / `multimethod` ã¯ **ã‚ã‚Šã¾ã›ã‚“**ã€‚
> * ãã®ä»£ã‚ã‚Šã€Œãƒ‡ãƒ¼ã‚¿ã®å½¢ã¯ `deftype` + `defenum`ã€ã€Œåˆ†å²ãƒ­ã‚¸ãƒƒã‚¯ã¯ `match`ã€ã¨ã„ã†ã‚·ãƒ³ãƒ—ãƒ«ãªæ§‹æˆã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚

---

## 1. `deftype` â€“ åå‰ä»˜ã product type

### 1.1 ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹

```clojure
(deftype Name {:field1 :type1 :field2 :type2 ...})

;; çœç•¥å¯èƒ½ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã¤ã
(deftype Name "Doc string"
  {:foo :int :bar :string})

;; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒ•ãƒ©ãƒƒãƒˆã«æ›¸ã
(deftype Name
  :field1 :type1
  :field2 :type2)
```

* `Name` ã¯ã‚·ãƒ³ãƒœãƒ«ï¼ˆ**ç¾åœ¨ã® ns å†…**ãƒ»å˜æ•°å½¢ã‚’æ¨å¥¨: `Dog`, `Cat`, `Human` ãªã©ï¼‰
* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰éƒ¨åˆ†ã¯ **ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ â†’ å‹ãƒ’ãƒ³ãƒˆ** ã®ãƒãƒƒãƒ—ã€ã¾ãŸã¯ãƒ•ãƒ©ãƒƒãƒˆå½¢å¼
* å‹ãƒ’ãƒ³ãƒˆã«ã¯ç¾åœ¨ãŠãŠã‚ˆãä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã‚’æƒ³å®š

  * ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–: `:int`, `:float`, `:string`, `:bool` ãªã©
  * åˆ¥ã®å‹åï¼ˆ`Dog`, `UserId` ãªã©ï¼‰

#### ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ï¼ˆçœç•¥è¨˜æ³•ï¼‰

`deftype` ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€map å½¢å¼ã«åŠ ãˆã¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¶æ•°åˆ—ã‚„çœç•¥è¨˜æ³•ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚

```clojure
(deftype Color :r Int :g Int :b Int :a Int)

(Color {r: 1, g: 2, b: 3, a: 4})
(Color :r 1, :g 2, :b 3, :a 4)
(Color r: 1, g: 2, b: 3, a: 4)

(def r 1) (def g 2)
(Color r:, g:)  ;; => (Color :r r :g g)
(Color :r, :g)  ;; => (Color :r r :g g)
```

* `:k v` ã®å¶æ•°åˆ—ã¯å†…éƒ¨çš„ã« map åŒ–ã•ã‚Œã‚‹
* `k:` / `:k` ã¯ `:k k` ã®çœç•¥ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ï¼ˆå‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—ã®ã¿ï¼‰
* çœç•¥ã—ãŸããªã„å ´åˆã¯ `{:k v}` ã® map å½¢å¼ã‚’ä½¿ã†

### 1.1.1 `:from` ã§æ—¢å®šã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åŒæ™‚å®šç¾©

`deftype` ã¨åŒæ™‚ã«ã€Œæ—¢å®šå€¤ï¼ˆå®šæ•°ï¼‰ã€ã‚’ 1 ã¤ã ã‘æŸç¸›ã§ãã¾ã™ã€‚

```clojure
(deftype Config :from cfg
  {:screen {:w 480 :h 640}
   :timing {:spawn-frames 92 :tick-ms 16}})

cfg
;; => (Config {...}) ã¨ç­‰ä¾¡
```

`def` å½¢å¼ã§ã‚‚åŒã˜æ„å‘³ã«ãªã‚Šã¾ã™ã€‚

```clojure
(deftype Config (def cfg
  {:screen {:w 480 :h 640}
   :timing {:spawn-frames 92 :tick-ms 16}}))
```

ãƒã‚¤ãƒ³ãƒˆ:

* `:from` ã®æŸç¸›ã¯ **æ˜ç¤ºçš„ã« 1 å€‹ã ã‘**ï¼ˆè‡ªå‹•ç”Ÿæˆãªã—ï¼‰
* æ—¢å®šå€¤ã®æ§‹é€ ã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‹ã‚’æ¨å®šã™ã‚‹ï¼ˆ`describe` ã«åæ˜ ï¼‰
* æ—¢å®šå€¤ã« `deftype :alias` ã®å€¤ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆã¯ **å‹åã‚’ä¿æŒ** ã™ã‚‹

### 1.2 ä½•ãŒå®šç¾©ã•ã‚Œã‚‹ã‹

```clojure
(ns examples::types::animals)

(deftype Dog {:name :string :age :int})
```

ã‚’è©•ä¾¡ã™ã‚‹ã¨ã€ç¾åœ¨ã® ns ã«ä»¥ä¸‹ãŒå®šç¾©ã•ã‚Œã¾ã™ã€‚

* ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿é–¢æ•° **`Dog`**
* è¿°èªé–¢æ•° **`Dog?`**
* å‹ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã¸ã®ãƒ¡ã‚¿æƒ…å ±ï¼ˆ`describe-type` ç”¨ï¼‰

å®Ÿéš›ã®æŒ™å‹•ä¾‹:

```clojure
(ns examples::types::animals)

(deftype Dog {:name :string :age :int})

[(type (Dog {:name "Pochi" :age 3}))
 (Dog? (Dog {:name "Pochi" :age 3}))
 (Dog? {:name "Fake" :age 2})]
;; =>
;; ['examples::types::animals::Dog
;;  true
;;  false]
```

* `type` â€¦ å€¤ã«ç´ã¥ãå‹ã® **å®Œå…¨ä¿®é£¾ã‚·ãƒ³ãƒœãƒ«** ã‚’è¿”ã™
* `Dog?` â€¦ ãã®å€¤ãŒ `Dog` å‹ã‹ã©ã†ã‹ã‚’åˆ¤å®š

### 1.3 å®Ÿä½“ã¯ã€Œæ™®é€šã® mapï¼‹å‹ã‚¿ã‚°ã€

`Dog` ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒè¿”ã™å€¤ã¯ã€è¦‹ãŸç›®ã¯ãµã¤ã†ã® map ã§ã™ã€‚

```clojure
(def pochi (Dog {:name "Pochi" :age 3}))

pochi
;; => {:name "Pochi" :age 3 ...}   ; è¡¨ç¤ºä¸Šã¯ãŸã ã® map

(type pochi)
;; => 'examples::types::animals::Dog

(Dog? pochi)
;; => true
```

å†…éƒ¨çš„ã«ã¯ã€Œã©ã® `deftype` ã‹ã‚‰ä½œã‚‰ã‚ŒãŸã‹ã€ãŒãƒ¬ã‚¸ã‚¹ãƒˆãƒªã«è¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€

* map ç³»ã®é–¢æ•°ï¼ˆ`get`, `assoc`, `update` ãªã©ï¼‰ãŒãã®ã¾ã¾ä½¿ãˆã‚‹
* ãã‚Œã§ã„ã¦ `type` / `Dog?` / `describe-type` ã§å‹æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹

ã¨ã„ã†æ§‹æˆã«ãªã£ã¦ã„ã¾ã™ã€‚

### 1.4 å‹ãƒ’ãƒ³ãƒˆã®æ‰±ã„ï¼ˆç¾æ™‚ç‚¹ï¼‰

ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æ›¸ã„ãŸ `:int` / `:string` ãªã©ã¯ **ã‚ãã¾ã§ãƒ’ãƒ³ãƒˆ** ã§ã™ã€‚

* å®Ÿè¡Œæ™‚ã®å³å¯†ãªå‹ãƒã‚§ãƒƒã‚¯ã¯ç¾æ™‚ç‚¹ã§ã¯è¡Œã„ã¾ã›ã‚“
* å°†æ¥ã®ç”¨é€”ã¨ã—ã¦:

  * LSP è£œå®Œãƒ»å‹ãƒ›ãƒãƒ¼
  * ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ / ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆ
  * å®Ÿè£…æ¬¡ç¬¬ã§ã¯ç°¡æ˜“æœ€é©åŒ–ï¼ˆãƒœã‚¯ã‚·ãƒ³ã‚°å›é¿ãªã©ï¼‰

ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚

> ã€Œãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼‹å°†æ¥çš„ãªæœ€é©åŒ–ã®ãƒ’ãƒ³ãƒˆã€ã¨æ€ã£ã¦æ›¸ã„ã¦ãŠã„ã¦ãã ã•ã„ã€‚

---

## 2. `defenum` â€“ Sum type / åˆ—æŒ™

`defenum` ã¯è¤‡æ•°ã® `deftype` ã‚’ã²ã¨ã¤ã®ã€Œã‚«ãƒ†ã‚´ãƒªã€ã¨ã—ã¦æŸã­ã‚‹ãŸã‚ã®æ§‹æ–‡ã§ã™ã€‚
ã‚¤ãƒ¡ãƒ¼ã‚¸ã¨ã—ã¦ã¯ã€Œ`Dog` ã¨ `Cat` ã‚’ã¾ã¨ã‚ã¦ `Pets` ã¨å‘¼ã¶ã€ã¨ã„ã£ãŸä½¿ã„æ–¹ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚

### 2.1 åŸºæœ¬å½¢

```clojure
(ns examples::types::animals)

(deftype Dog {:name :string})
(deftype Cat {:name :string})

(defenum Pets
  Dog
  Cat)
```

* `Pets` â€¦ ã€Œ`Dog` ã¾ãŸã¯ `Cat` ã®ã©ã¡ã‚‰ã‹ã€ã¨ã„ã†æ„å‘³ã® enum
* **æ…£ç¿’** ã¨ã—ã¦ enum åã¯è¤‡æ•°å½¢ / ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³åã‚’æ¨å¥¨

  * ä¾‹: `Pets`, `Mammals`, `Animals`, `ErrorKinds` ãªã©
* ãƒ¡ãƒ³ãƒãƒ¼ã¯ **åŒã˜ ns å†…** ã«ã‚ã‚‹ `deftype` åã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™

### 2.2 ãƒ¡ã‚¿æƒ…å ±ã¨ introspection

`deftype` / `defenum` ã‚’è©•ä¾¡ã™ã‚‹ã¨ã€å†…éƒ¨ã®å‹ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã«ãƒ¡ã‚¿æƒ…å ±ãŒç™»éŒ²ã•ã‚Œã¾ã™ã€‚
`describe-type` ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã§ã€å‹ã®æƒ…å ±ã‚’ map ã¨ã—ã¦å–å¾—ã§ãã¾ã™ã€‚

```clojure
(describe-type 'Pets)
;; ãŠãŠã‚ˆã:
;; {:kind    'sum
;;  :ns      'examples::types::animals
;;  :name    'Pets
;;  :fqn     'examples::types::animals::Pets
;;  :members ['examples::types::animals::Dog
;;            'examples::types::animals::Cat]
;;  ...}

(describe-type 'Dog)
;; ãŠãŠã‚ˆã:
;; {:kind        'product
;;  :ns          'examples::types::animals
;;  :name        'Dog
;;  :fqn         'examples::types::animals::Dog
;;  :fields      {:name :string}
;;  :belongs-to  ['examples::types::animals::Pets]
;;  ...}
```

â€» ã‚­ãƒ¼ã®åå‰ã‚„å€¤ã¯å®Ÿè£…ã«æº–æ‹ ã—ã¾ã™ãŒã€æ¦‚å¿µã¨ã—ã¦ã¯ä¸Šè¨˜ã®ã‚ˆã†ãªæ§‹é€ ã§ã™ã€‚
`kind` / `ns` / `name` / `fqn` / `fields` / `belongs-to` / `members` ãªã©ãŒå«ã¾ã‚Œã¾ã™ã€‚

### 2.3 enum ã®ãƒã‚¹ãƒˆï¼ˆå°†æ¥æ¡ˆï¼‰

åˆ¥ã® enum ã‚’ã€Œã¾ã¨ã‚ã¦å«ã‚ã‚‹ã€ãŸã‚ã« `*Pets` ã®ã‚ˆã†ãªè¨˜æ³•ã‚’å°å…¥ã™ã‚‹æ¡ˆãŒã‚ã‚Šã¾ã™ã€‚

```clojure
(defenum Mammals
  Dog
  Cat
  Human)

(defenum Animals
  *Mammals
  Salmon)
```

* ç¾åœ¨ã¯ã¾ã  **è¨­è¨ˆæ®µéš** ã§ã‚ã‚Šã€ä»•æ§˜ã¨ã—ã¦ã¯å›ºå®šã—ã¦ã„ã¾ã›ã‚“ã€‚
* å®Ÿè£…ãŒå…¥ã£ãŸã‚‰ã€ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå´ã‚‚è¿½å¾“ã—ã¦æ›´æ–°ã™ã‚‹äºˆå®šã§ã™ã€‚

---

## 3. `match` â€“ ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

`match` ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå€¤ã«å¯¾ã—ã¦è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¸Šã‹ã‚‰é †ã«è©¦ã—ã€
æœ€åˆã«ãƒãƒƒãƒã—ãŸè¡Œã®å¼ã‚’è©•ä¾¡ã™ã‚‹ special form ã§ã™ã€‚

`deftype` / `defenum` ã¨çµ„ã¿åˆã‚ã›ã‚‹ã¨ã€ML / Haskell é¢¨ã®æ›¸ãå¿ƒåœ°ã«ã‹ãªã‚Šå¯„ã›ã‚‰ã‚Œã¾ã™ã€‚

### 3.1 åŸºæœ¬å½¢

```clojure
(match value
  pattern-1 expr-1
  pattern-2 expr-2
  ...
  _         default-expr)
```

* å·¦: **ãƒ‘ã‚¿ãƒ¼ãƒ³**
* å³: ãƒãƒƒãƒã—ãŸã¨ãã«è©•ä¾¡ã•ã‚Œã‚‹ **å¼**
* ä¸Šã‹ã‚‰é †ç•ªã«è©•ä¾¡ã—ã€æœ€åˆã«ãƒãƒƒãƒã—ãŸ 1 è¡Œã ã‘ãŒå®Ÿè¡Œã•ã‚Œã¾ã™
* `_` ã¯ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ï¼ˆãªã‚“ã§ã‚‚ãƒãƒƒãƒï¼‰

### 3.2 å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‹map ãƒ‘ã‚¿ãƒ¼ãƒ³

`deftype` ã¨ä¸€ç·’ã«ä½¿ã†åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€Œå‹ï¼‹map ã®å½¢ã€ã§ã™ã€‚

```clojure
(ns examples::types::animals)

(deftype Dog {:name :string})
(deftype Cat {:name :string})

(defenum Pets
  Dog
  Cat)

(defn describe [pet]
  (match pet
    (Dog {:name n}) (str n " the dog")
    (Cat {:name n}) (str n " the cat")
    _              "unknown"))
```

* `(Dog {:name n})`

  * ã€Œ`Dog` å‹ ã‹ã¤ `:name` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–ã‚Šå‡ºã—ã¦ `n` ã«æŸç¸›ã€
* `(Cat {:name n})`

  * åŒæ§˜ã« `Cat` å‹ã®ã¨ãã«ã ã‘ãƒãƒƒãƒ

### 3.3 `:as` ã§ã€Œå€¤å…¨ä½“ã€ã‚‚åŒæ™‚ã«å—ã‘å–ã‚‹

ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åˆ†è§£ã—ã¤ã¤ã€å…ƒã®å€¤å…¨ä½“ã‚‚è¦‹ãŸã„å ´åˆã¯ `:as` ã‚’ä½¿ã„ã¾ã™ã€‚

```clojure
(defn describe [pet]
  (match pet
    (Dog {:name n}) :as whole
      (if (Dog? whole)
        (str n " the dog")
        "not a dog")

    (Cat {:name n}) (str n " the cat")
    _               "unknown"))
```

* `(Dog {:name n}) :as whole expr`

  * `:name` ã¯ `n` ã«æŸç¸›
  * å€¤å…¨ä½“ï¼ˆ`(Dog {...})` ã®çµæœï¼‰ã¯ `whole` ã«æŸç¸›

### 3.4 `:when` ã§ã‚¬ãƒ¼ãƒ‰æ¡ä»¶

ã•ã‚‰ã«ã€Œç‰¹å®šã®æ¡ä»¶ã‚’æº€ãŸã™ã¨ãã ã‘ã€ãƒãƒƒãƒã•ã›ãŸã„å ´åˆã¯ `:when` ã‚’ä½¿ã„ã¾ã™ã€‚

```clojure
(defn describe [pet]
  (match pet
    (Dog {:name n}) :as whole
      (if (Dog? whole)
        (str n " the dog")
        "not a dog")

    (Cat {:name n}) :when (= n "Mimi")
      (str n " the picky cat")

    (Cat {:name n})
      (str n " the cat")

    _ "unknown"))
```

ã“ã®ä¾‹ã§ã¯:

1. `Dog` å‹ãªã‚‰ `Dog?` ã§ã‚‚ã†ä¸€åº¦ãƒã‚§ãƒƒã‚¯ã—ã¤ã¤ dog ç”¨æ–‡è¨€
2. `Cat` å‹ã‹ã¤åå‰ãŒ `"Mimi"` ã®ã¨ãã ã‘ã€Œpicky catã€
3. ãã®ä»–ã® `Cat` ã¯ãµã¤ã†ã® cat è¡¨è¨˜
4. ãã‚Œä»¥å¤–ã¯ `"unknown"`

ã¨ã„ã†é †ã«ãƒãƒƒãƒã—ã¦ã„ãã¾ã™ã€‚

### 3.5 è©•ä¾¡é †ãƒ»å®Œå…¨æ€§

`match` ã®è©•ä¾¡é †ã¯ã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã€‚

1. ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¸Šã‹ã‚‰é †ã«è©¦ã™
2. ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãŸè¡ŒãŒã‚ã‚Œã°:

   * `:when` ãŒã‚ã‚Œã°ãã®æ¡ä»¶å¼ã‚’è©•ä¾¡
   * æ¡ä»¶ãŒçœŸãªã‚‰å³å´ã®å¼ã‚’è©•ä¾¡ã—ã¦å³çµ‚äº†
   * å½ãªã‚‰æ¬¡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¸
3. ã©ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚‚ãƒãƒƒãƒã—ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼ã€ã¾ãŸã¯ `_`ï¼ˆãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ï¼‰ãŒã‚ã‚Œã°ãã‚ŒãŒä½¿ã‚ã‚Œã‚‹

> âš ï¸ ç¾æ™‚ç‚¹ã§ã¯ **ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆexhaustiveness checkï¼‰ã¯ã‚ã‚Šã¾ã›ã‚“**ã€‚
> `_` ãªã©ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è‡ªåˆ†ã§ç”¨æ„ã—ã¦ãã ã•ã„ã€‚

---

## 4. åˆ©ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è¨­è¨ˆã®ãƒ’ãƒ³ãƒˆ

### 4.1 ã€Œåå‰ä»˜ã mapã€ã¨ã—ã¦ã® `deftype`

`deftype` ã¯ã€ã‚‚ã¨ã‚‚ã¨ map ã§è¡¨ç¾ã—ã¦ã„ãŸãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ã«ã€Œåå‰ã‚’ä¸ãˆã‚‹ã€ç”¨é€”ã«å‘ã„ã¦ã„ã¾ã™ã€‚

ä¾‹:

```clojure
(deftype Player {:id :int :name :string})
(deftype Enemy  {:id :int :kind :string})

(defenum Actors
  Player
  Enemy)
```

* DB ãƒ¬ã‚³ãƒ¼ãƒ‰ / HTTP ãƒ¬ã‚¹ãƒãƒ³ã‚¹ / è¨­å®šå€¤ãªã©ã‚’ map ã§ãã®ã¾ã¾æ‰±ãˆã‚‹
* ãã‚Œã§ã„ã¦ `Player?` / `Enemy?` / `type` ã§å‹ã‚’åŒºåˆ¥ã§ãã‚‹

### 4.2 enum + match ã§ã€Œåˆ†å²ã®å…¥å£ã€ã‚’ä¸€æœ¬åŒ–

ã€Œå‹ã”ã¨ã«åˆ†å²ã™ã‚‹å‡¦ç†ã€ã¯ã€ãªã‚‹ã¹ã 1 ç®‡æ‰€ã«ã¾ã¨ã‚ã¦ãŠãã¨èª­ã¿ã‚„ã™ããªã‚Šã¾ã™ã€‚

```clojure
(defn handle-event [event]
  (match event
    (Player {:id id}) (handle-player id)
    (Enemy  {:id id}) (handle-enemy  id)
    _                 (handle-unknown event)))
```

ã“ã†ã—ã¦ãŠãã¨ã€æ–°ã—ã„å‹ã‚’è¿½åŠ ã—ãŸããªã£ãŸã¨ãã‚‚

* `defenum` ã«ãƒ¡ãƒ³ãƒãƒ¼ã‚’ 1 è¡Œè¿½åŠ 
* è©²å½“ã™ã‚‹ `match` ã«åˆ†å²ã‚’ 1 è¡Œè¿½åŠ 

ã¨ã„ã†ãƒ‘ã‚¿ãƒ¼ãƒ³ã§æ‹¡å¼µã§ãã¾ã™ã€‚

### 4.3 Clojure ã® protocol / multimethod ã®ä»£æ›¿ã¨ã—ã¦

Clove ã«ã¯ `protocol` / `multimethod` ãŒç„¡ã„ä»£ã‚ã‚Šã«ã€

* `deftype` ã§ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆshapeï¼‰ã‚’å®šç¾©
* åå‰ç©ºé–“ã”ã¨ã«ã€Œãã®å‹ã‚’å—ã‘å–ã‚‹é–¢æ•°ç¾¤ã€ã‚’ã¾ã¨ã‚ã‚‹
* å‹ã«ã‚ˆã‚‹åˆ†å²ãŒå¿…è¦ãªéƒ¨åˆ†ã¯ `match` ã«é–‰ã˜è¾¼ã‚ã‚‹

ã¨ã„ã†ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚

```clojure
(ns app::render
  (require app::types :as t))

(defn render-entity [entity]
  (match entity
    (t::Player {:id id}) (render-player entity)
    (t::Enemy  {:id id}) (render-enemy  entity)
    _                    (render-fallback entity)))
```

* ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ­ã‚¸ãƒƒã‚¯ã®å…¥å£ãŒ `render-entity` ã«é›†ç´„ã•ã‚Œã‚‹
* ãƒ‡ãƒ¼ã‚¿ã¯ã‚ãã¾ã§ map ãªã®ã§ã€å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚„ JSON/YAML ã¨ã®ç›¸äº’é‹ç”¨ã‚‚ç°¡å˜

---

## 5. ã¾ã¨ã‚

* `deftype` ã¯ã€Œåå‰ä»˜ã product typeï¼ˆä¸­èº«ã¯ mapï¼‰ã€ã‚’å®šç¾©ã—ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»è¿°èªãƒ»ãƒ¡ã‚¿æƒ…å ±ã‚’æä¾›ã™ã‚‹ã€‚
* `defenum` ã¯è¤‡æ•°ã® `deftype` ã‚’ã²ã¨ã¤ã®ã‚«ãƒ†ã‚´ãƒªã¨ã—ã¦æŸã­ã‚‹ã€‚
* `match` ã¯ãã‚Œã‚‰ã®å‹ã«å¯¾ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§åˆ†å²ã‚’æ›¸ããŸã‚ã® special formã€‚
* ã©ã‚Œã‚‚ **è»½é‡ãª ADT é¢¨** ã«æŒ¯ã‚‹èˆã„ã¤ã¤ã€å®Ÿä½“ã¯ map ãƒ™ãƒ¼ã‚¹ãªã®ã§ Clove å…¨ä½“ã®ä¸–ç•Œè¦³ã¨ã‚‚ç›¸æ€§ãŒè‰¯ã„ã€‚

ä»Šå¾Œã€LSPãƒ»ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆãƒ»æœ€é©åŒ–ãªã©ã§ã€ã“ã®å‹æƒ…å ±ã‚’ã•ã‚‰ã«æ´»ç”¨ã—ã¦ã„ãäºˆå®šã§ã™ã€‚

---

## ä»˜éŒ²: æ§‹æ–‡æ‹¡å¼µã¯ `use-syntax` ã§ON/OFFã§ãã‚‹

Clove ã«ã¯ Reader ãƒ¬ãƒ™ãƒ«ã®æ‹¡å¼µãŒã„ãã¤ã‹ã‚ã‚Šã€å®Ÿè¡Œæ™‚ã«åˆ‡ã‚Šæ›¿ãˆã§ãã¾ã™ã€‚

```clojure
(use-syntax dot-chain true)
(use-syntax indexer true)
(use-syntax foreign-block true)
(use-syntax oop-syntax true)
```

- ã©ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ON ã‹ã¯ã€REPL / å®Ÿè¡Œç’°å¢ƒã®è¨­å®šã«ä¾å­˜ã—ã¾ã™ã€‚
- â€œã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ä½¿ã†/ä½¿ã‚ãªã„â€ ã‚’æ˜ç¤ºã—ãŸã„ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚

è©³ã—ãã¯ [å®Ÿè¡Œæ™‚è¨­å®š](../advanced/runtime_settings.ja.md)ã€‚

---
<!-- NAV:START -->
**å‰ã¸:** [Getting Started](../getting_started.ja.md)
**æ¬¡ã¸:** [REPL ã‚¬ã‚¤ãƒ‰](../tooling/repl.ja.md)
<!-- NAV:END -->

