use std::fs;
use std::io;
use std::path::{Path, PathBuf};
use std::time::{SystemTime, UNIX_EPOCH};

use clove_core::type_registry::{self, TypeEntry};

use crate::docs::{all_docs, signature_params_for};

const STUB_FILENAME: &str = "builtin_stubs.clv";
const LSP_VERSION: &str = env!("CARGO_PKG_VERSION");

pub struct StubFile {
    pub path: PathBuf,
    pub contents: String,
}

pub fn ensure_stub_file(workspace_hash: &str) -> Option<StubFile> {
    let dir = stub_dir(workspace_hash);
    if fs::create_dir_all(&dir).is_err() {
        return None;
    }
    let path = dir.join(STUB_FILENAME);
    let contents = build_stub_contents();
    let needs_write = fs::read_to_string(&path)
        .map(|existing| existing != contents)
        .unwrap_or(true);
    if needs_write && write_atomic(&path, &contents).is_err() {
        return None;
    }
    Some(StubFile { path, contents })
}

fn build_stub_contents() -> String {
    let mut out = String::new();
    out.push_str(";; Auto-generated by clove-lsp\n");
    out.push_str(";; Builtin stubs to support go-to-definition for core functions and types.\n\n");
    out.push_str("(ns clove.builtins)\n\n");
    out.push_str(";; Builtin type stubs\n");
    for name in builtin_type_entries() {
        let (display, head) = name;
        out.push_str(&format!("({} {} {{}})\n\n", head, display));
    }
    out.push_str("(deftype Any {})\n\n");
    for entry in all_docs() {
        out.push_str(&format!(
            ";; {} ({})\n",
            entry.name,
            entry.origin.clone().unwrap_or_default()
        ));
        if let Some(sig) = &entry.signature {
            out.push_str(&format!(";; signature: {}\n", sig));
        }
        if let Some(doc) = &entry.doc {
            for line in doc.lines() {
                out.push_str(";; ");
                out.push_str(line);
                out.push('\n');
            }
        }
        let params = signature_params_for(entry)
            .filter(|params| !params.is_empty())
            .map(|params| {
                let joined = params
                    .into_iter()
                    .map(|p| sanitize_stub_param(&p))
                    .collect::<Vec<_>>()
                    .join(" ");
                format!("[{}]", joined)
            })
            .unwrap_or_else(|| "[& args]".to_string());
        let docstring = entry
            .doc
            .as_ref()
            .map(|doc| escape_docstring(doc))
            .unwrap_or_else(|| "Builtin stub generated by clove-lsp.".to_string());
        out.push_str(&format!(
            "(defn {}\n  \"{}\"\n  {}\n  (core::runtime-error \"{} is implemented in Rust\"))\n\n",
            entry.name, docstring, params, entry.name
        ));
    }
    out
}

fn builtin_type_entries() -> Vec<(String, &'static str)> {
    let mut entries = Vec::new();
    for name in type_registry::list_all_types() {
        let display = display_registry_type_name(&name);
        let head = match type_registry::get_type_entry(&name) {
            Some(TypeEntry::Sum(_)) => "defenum",
            _ => "deftype",
        };
        entries.push((display, head));
    }
    entries.sort_by(|a, b| a.0.cmp(&b.0));
    entries.dedup_by(|a, b| a.0 == b.0);
    entries
}

fn display_registry_type_name(name: &str) -> String {
    let name = name.strip_prefix("clove::").unwrap_or(name);
    if let Some(stripped) = name.strip_prefix("core::") {
        return stripped.to_string();
    }
    name.to_string()
}

fn sanitize_stub_param(param: &str) -> String {
    param.replace('/', "-")
}

fn escape_docstring(input: &str) -> String {
    input
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .lines()
        .collect::<Vec<_>>()
        .join("\\n")
}

fn stub_dir(workspace_hash: &str) -> PathBuf {
    std::env::temp_dir()
        .join("clove-lsp")
        .join(LSP_VERSION)
        .join(workspace_hash)
}

fn write_atomic(path: &Path, contents: &str) -> io::Result<()> {
    let dir = path
        .parent()
        .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "stub dir missing"))?;
    let tmp_path = dir.join(format!("{}.tmp-{}", STUB_FILENAME, unique_suffix()));
    fs::write(&tmp_path, contents)?;
    match fs::rename(&tmp_path, path) {
        Ok(()) => Ok(()),
        Err(_) => {
            let _ = fs::remove_file(path);
            if fs::rename(&tmp_path, path).is_ok() {
                return Ok(());
            }
            fs::copy(&tmp_path, path)?;
            fs::remove_file(&tmp_path)?;
            Ok(())
        }
    }
}

fn unique_suffix() -> String {
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_nanos();
    format!("{}-{}", std::process::id(), nanos)
}
